const char *th_em_modulesrc[] = {
"// Module for frame based image animation.\n"
"// TODO: Rework this module to use atlases.\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"image.um\"\n"
"\t\"rect.um\"\n"
")\n"
"\n"
"// Anim is able to animate an array of images. As opposed to ent.Ent.animate,\n"
"// it starts from the first frame.\n"
"type Anim* = struct {\n"
"\tanim: []image.Image\n"
"\trot: th.fu\n"
"\tscale: th.fu\n"
"\tfps: th.uu\n"
"\tlooping: bool\n"
"\n"
"\tpos: th.Vf2\n"
"\n"
"\tzeroTime: int\n"
"\n"
"\tframe: int\n"
"}\n"
"\n"
"// Anim\'s constructor.\n"
"fn mk*(pos: th.Vf2, anm: []image.Image, fps: th.uu): Anim {\n"
"\ta := Anim{}\n"
"\n"
"\ta.anim = append(anm, anm[len(anm)-1])\n"
"\n"
"\ta.fps = fps\n"
"\ta.scale = 1\n"
"\ta.rot = 0\n"
"\n"
"\ta.pos = pos\n"
"\n"
"\ta.looping = false\n"
"\n"
"\treturn a\n"
"}\n"
"\n"
"// Starts animation with start_time of t.\n"
"fn (a: ^Anim) start*(t: int) {\n"
"\ta.zeroTime = t\n"
"}\n"
"\n"
"// This draws the animation. Returns true, if the animation ended.\n"
"fn (a: ^Anim) handle*(t: uint, cam: rect.Rect): bool {\n"
"\ta.frame = (round(real(t-a.zeroTime)/round((1000.0/a.fps))) % len(a.anim))\n"
"\n"
"\ta.anim[a.frame].draw(\n"
"\t\tth.Transform{\n"
"\t\t\tth.Vf2{round(a.pos.x) - cam.x + cam.w/2, round(a.pos.y) - cam.y + cam.h/2},\n"
"\t\t\tth.Vf2{a.scale, a.scale}, th.Vf2{}, a.rot})\n"
"\n"
"\tif a.frame == len(a.anim) - 1 {\n"
"\t\tif a.looping {\n"
"\t\t\ta.zeroTime = t\n"
"\t\t} else {\n"
"\t\t\treturn true\n"
"\t\t}\n"
"\t}\n"
"\n"
"\treturn false\n"
"}\n"
"",
"// Module for audio loading and playback.\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
")\n"
"\n"
"// A structure used to create playbacks.\n"
"type Sound* = struct {\n"
"\tlooping: bool\n"
"\tvolume: th.fu\n"
"\tpath: str\n"
"}\n"
"\n"
"// Playback is a currently played instance of a sound.\n"
"// The properties are set to the value the sound has.\n"
"// sound.play returns a pointer. Be sure to keep it if you want to\n"
"// change the sound while its playing.\n"
"type Playback* = struct{\n"
"\tdecoder: ^struct{}\n"
"\t// Indicates if the sound is playing.\n"
"\tplaying: bool\n"
"\t// If set to true, playback will be paused.\n"
"\tpaused: bool\n"
"\t// If true, playback will keep on playing again after it ends.\n"
"\tlooping: bool\n"
"\t// Multiplier of the volume.\n"
"\tvolume: th.fu\n"
"\t// Sets the current PCM frame. Write only.\n"
"\tframe: int\n"
"}\n"
"\n"
"fn csoundplay(s: ^Sound): ^Playback\n"
"\n"
"// Loads sound at a path.\n"
"fn load*(path: str): Sound {\n"
"\treturn Sound{\n"
"\t\tlooping: false,\n"
"\t\tvolume: 1,\n"
"\t\tpath: path }\n"
"}\n"
"\n"
"// Plays the sound.\n"
"fn (s: ^Sound) play*(): ^Playback {\n"
"\treturn csoundplay(s)\n"
"}\n"
"",
"\n"
"// Parses input into a 2d string array.\n"
"fn parse*(inp: str): [][]str {\n"
"\tlength := len(inp)\n"
"\toutLen := 0\n"
"\tout := [][]str{}\n"
"\trow := []str{}\n"
"\tstart := 0\n"
"\n"
"\tfor i := 0; i < length; i++ {\n"
"\t\tif inp[i] == \'\\n\' {\n"
"\t\t\trow = append(row, slice(inp, start, i))\n"
"\n"
"\t\t\tif outLen % 64 == 0 {\n"
"\t\t\t\tvar more: [64][]str\n"
"\t\t\t\tout = append(out, more)\n"
"\t\t\t}\n"
"\n"
"\t\t\tout[outLen] = row\n"
"\t\t\toutLen++\n"
"\n"
"\t\t\trow = []str{}\n"
"\t\t\tstart = i+1\n"
"\t\t} else if inp[i] == \',\' {\n"
"\t\t\trow = append(row, slice(inp, start, i))\n"
"\t\t\tstart = i+1\n"
"\t\t}\n"
"\t}\n"
"\n"
"\treturn slice(out, 0, outLen)\n"
"}\n"
"\n"
"// Converts 2d array to csv string.\n"
"fn encode*(inp: [][]str): str {\n"
"\tstrLen := 1\n"
"\tfor i in inp {\n"
"\t\tfor j in inp[i] {\n"
"\t\t\tstrLen += len(inp[i][j])\n"
"\t\t\tstrLen += 1 // Comma, Newline\n"
"\t\t}\n"
"\t}\n"
"\n"
"\tout := make([]char, strLen)\n"
"\toutI := 0\n"
"\n"
"\tfor i:=0; i < len(inp); i++ {\n"
"\t\tfor j:=0; j < len(inp[i]); j++ {\n"
"\t\t\tfor _, c in inp[i][j] {\n"
"\t\t\t\tout[outI] = c\n"
"\t\t\t\toutI++\n"
"\t\t\t}\n"
"\t\t\tif j < len(inp[i])-1 { out[outI] = \',\'; outI++ }\n"
"\t\t}\n"
"\t\tout[outI] = \'\\n\'\n"
"\t\toutI += 1\n"
"\t}\n"
"\treturn out\n"
"}\n"
"\n"
"",
"\n"
"import (\n"
"\t\"rect.um\"\n"
"\t\"image.um\"\n"
"\t\"th.um\"\n"
")\n"
"\n"
"// Entity is the main game object. It features drawing and collisions.\n"
"// Every entity has an image used for drawing and a rectangle used\n"
"// for collisions. It also has a transform used for transforming it\'s image\n"
"// and rectangle.\n"
"type Ent* = struct {\n"
"\t// used as a collider, used as backup when invalid image is supplied\n"
"\tr: rect.Rect\n"
"\t// used in drawing\n"
"\ti: image.Image\n"
"\t// used to transform and translate the image and rect\n"
"\tt: th.Transform\n"
"\t// used as a color of the rect and a color filter for the image\n"
"\tc: uint32\n"
"}\n"
"\n"
"// Value returned by get coll. It contains a position where the collision\n"
"// happened and the index of the entity involved in said collision.\n"
"type Coll* = struct {\n"
"\tindex: th.uu\n"
"\tpos: th.Vf2\n"
"}\n"
"\n"
"fn centdraw(e: ^Ent, c: ^rect.Rect)\n"
"\n"
"// Draws the entity onto the screen in relaction to camera c.\n"
"fn (e: ^Ent) draw*(c: rect.Rect) {\n"
"\tcentdraw(e, &c)\n"
"}\n"
"\n"
"fn cgetcoll(coll: ^Coll, collC: ^int, maxCount: th.uu, count: int32, e: ^Ent, s: ^^Ent)\n"
"\n"
"// ent\'s constructor\n"
"fn mk*(img: image.Image = image.Image{}, t: th.Transform = th.Transform{ s: th.Vf2{1, 1} }): Ent {\n"
"\tvar e: Ent\n"
"\te.i = img\n"
"\te.t = t\n"
"\tif img.validate() {\n"
"\t\tdm := img.getDims()\n"
"\t\te.r.w = dm.x\n"
"\t\te.r.h = dm.y\n"
"\t}\n"
"\te.c = th.white\n"
"\n"
"\tif t.s.x == 0 && t.s.y == 0 {\n"
"\t\tt.s = th.Vf2{ 1, 1 }\n"
"\t}\n"
"\n"
"\treturn e\n"
"}\n"
"\n"
"// Checks collisions of e with entities in s. Checks at max maxColl collisions.\n"
"// If s contains e, the collision won\'t be returned.\n"
"fn (e: ^Ent) getColl*(s: []^Ent, maxColls: th.uu): []Coll {\n"
"\tif len(s) == 0 {\n"
"\t\treturn []Coll{}\n"
"\t}\n"
"\n"
"\tif maxColls > len(s) {\n"
"\t\tmaxColls = len(s)\n"
"\t}\n"
"\n"
"\tif maxColls == 0 {\n"
"\t\tmaxColls = 1\n"
"\t}\n"
"\n"
"\tcolls := make([]Coll, maxColls)\n"
"\tcount := 0\n"
"\tcgetcoll(&colls[0], &count, maxColls, len(s), e, &s[0])\n"
"\n"
"\treturn slice(colls, 0, count)\n"
"}\n"
"\n"
"// Animates the entity\'s image with one of the `anim` array. <b>Won\'t</b> begin on\n"
"// the first frame. If you want that, use anim.Anim.\n"
"fn (e: ^Ent) animate*(fps: int, frames: ^[]image.Image, t: int) {\n"
"\te.i = frames^[(round(real(t)/(1000/fps)) % len(frames^))]\n"
"}\n"
"\n"
"fn centysort(e: ^ent.Ent, count: int)\n"
"\n"
"// Performs an y sort on entities.\n"
"fn ysort*(ents: ^[]ent.Ent) {\n"
"\tif len(ents^) > 0 {\n"
"\t\tcentysort(&ents[0], len(ents^))\n"
"\t}\n"
"}\n"
"",
"import (\n"
"\t\"rect.um\"\n"
"\t\"th.um\"\n"
")\n"
"\n"
"// Represents a drawable image. It is an opaque structure.\n"
"// Images support a color filter. It is applied by multiplying the color\n"
"// of each pixel with the filter.\n"
"type Image* = struct{ _: ^struct{} }\n"
"\n"
"fn loadimg(ret: ^Image, path: str)\n"
"fn flipvimg(i: Image, f: bool)\n"
"fn fliphimg(i: Image, f: bool)\n"
"fn cdrawimage(img: Image, t: ^th.Transform, color: uint32)\n"
"fn imggetdims(dm: ^th.Vf2, i: Image)\n"
"fn imgcrop(img: Image, tl, br: th.Vf2)\n"
"fn imgcropquad(img: Image, q: ^th.Quad)\n"
"fn imggetcropquad(img: Image, q: ^th.Quad)\n"
"fn imgfromdata(ret: ^Image, data: ^uint32, dm: th.Vf2)\n"
"fn imgcopy(ret: ^Image, data: Image)\n"
"fn imgsetfilter(data: Image, filter: int)\n"
"fn imgdrawonquad(img: Image, color: uint32, q: th.Quad)\n"
"fn imgdrawninepatch(img: Image, outer, inner, dest: ^rect.Rect, color: uint32)\n"
"fn imgupdatedata(img: Image, data: ^uint32, dm: th.Vf2)\n"
"fn imggetdata(img: Image, data: ^uint32)\n"
"fn imgmakerendertarget(img: Image)\n"
"fn imgremoverendertarget(img: Image, cam: ^rect.Rect)\n"
"\n"
"// Loads an image at path.\n"
"fn load*(path: str): Image {\n"
"\timg := Image{}\n"
"\tloadimg(&img, path)\n"
"\treturn img\n"
"}\n"
"\n"
"// Flips image on it\'s vertical axis.\n"
"fn (i: ^Image) flipv*(flip: bool) {\n"
"\tflipvimg(i^, flip)\n"
"}\n"
"\n"
"// Flips image on it\'s horizontal axis.\n"
"fn (i: ^Image) fliph*(flip: bool) {\n"
"\tfliphimg(i^, flip)\n"
"}\n"
"\n"
"// Draws the image in screen coordinates. It transforms it with t and\n"
"// applies color as a color filter.\n"
"fn (i: ^Image) draw*(t: th.Transform, color: uint32 = th.white) {\n"
"\tcdrawimage(i^, &t, color)\n"
"}\n"
"\n"
"// Draws \"nine-patch\" image. \n"
"// `outer` specifies the texture coordinates of the outer rect of source image,\n"
"// `inner` specifies coordinates of inner rect of source image, positioned relative to `outer`.\n"
"// You can tint with `color`.\n"
"fn (i: ^Image) drawNinepatch*(outer, inner, dest: rect.Rect, color: uint32 = th.white) {\n"
"\timgdrawninepatch(i^, &outer, &inner, &dest, color)\n"
"}\n"
"\n"
"// Draws the image on top of a quad with corners of the image positioned\n"
"// on the verticies of the quad.\n"
"fn (i: ^Image) drawOnQuad*(q: th.Quad, color: uint32 = th.white) {\n"
"\timgdrawonquad(i^, color, q)\n"
"}\n"
"\n"
"// Returns true, if i\'s handle points to an image.\n"
"fn (i: ^Image) validate*(): bool {\n"
"\treturn i._ != null\n"
"}\n"
"\n"
"// Returns width and heigth.\n"
"fn (i: ^Image) getDims*(): th.Vf2 {\n"
"\tout := th.Vf2{}\n"
"\timggetdims(&out, i^)\n"
"\n"
"\treturn out\n"
"}\n"
"\n"
"// Crops an image. Coordinates are between 0, 0 (top left) and\n"
"// 1, 1 (bottom right)\n"
"fn (i: ^Image) crop*(tl, br: th.Vf2) {\n"
"\timgcrop(i^, tl, br)\n"
"}\n"
"\n"
"// Crop an image using a quad.\n"
"fn (i: ^Image) cropQuad*(q: th.Quad) {\n"
"\timgcropquad(i^, &q)\n"
"}\n"
"\n"
"// Crop an image using a quad.\n"
"fn (i: ^Image) getCropQuad*(): th.Quad {\n"
"\tvar (q: th.Quad)\n"
"\timggetcropquad(i^, &q)\n"
"\treturn q\n"
"}\n"
"\n"
"// Creates an image from raw data.\n"
"fn mk*(data: []uint32, dm: th.Vf2): Image {\n"
"\timg := Image{}\n"
"\timgfromdata(&img, &data[0], dm)\n"
"\n"
"\treturn img\n"
"}\n"
"\n"
"// Copies image into a new one.\n"
"fn (i: ^Image) copy*(): Image {\n"
"\timg := Image{}\n"
"\timgcopy(&img, i^)\n"
"\t\n"
"\treturn img\n"
"}\n"
"\n"
"// Sets a mag/min filter. 0 is linear, others are nearest.\n"
"// This function will regenerate the texture. This means it shouldn\'t be\n"
"// used in a loop.\n"
"// https://learnopengl.com/img/getting-started/texture_filtering.png\n"
"// left is nearest, right is linear.\n"
"fn (i: ^Image) setfilter*(filter: int) {\n"
"\timgsetfilter(i^, filter)\n"
"}\n"
"\n"
"// Updates the image data. dm are the dimensions of the new image.\n"
"// The new image doesn\'t have to be the same size as the old one.\n"
"fn (i: ^Image) setData*(data: []uint32, dm: th.Vf2) {\n"
"\tif dm.x * dm.y != len(data) {\n"
"\t\terror(\"setData: incorrect dimensions: \" + repr(dm.x * dm.y) + \"!= \" + repr(len(data)))\n"
"\t}\n"
"\n"
"\tif len(data) == 0 {\n"
"\t\terror(\"setData: can\'t set empty image\")\n"
"\t}\n"
"\n"
"\timgupdatedata(i^, &data[0], dm)\n"
"}\n"
"\n"
"// Gets the image data.\n"
"fn (i: ^Image) getData*(): []uint32 {\n"
"\tif i._ == null {\n"
"\t\treturn []uint32{}\n"
"\t}\n"
"\n"
"\tbuf := make([]uint32, trunc(i.getDims().x * i.getDims().y))\n"
"\tif len(buf) == 0 {\n"
"\t\treturn buf\n"
"\t}\n"
"\n"
"\timggetdata(i^, &buf[0])\n"
"\n"
"\treturn buf\n"
"}\n"
"\n"
"// Sets the image a the render target. This means stuff won\'t be drawn onto the\n"
"// screen, but into the image. In this mode, the scaling is always 1. An the\n"
"// resolution of the screen are the image\'s dimensions.\n"
"fn (i: ^Image) makeRenderTarget*() {\n"
"\timgmakerendertarget(i^)\n"
"}\n"
"\n"
"// Returns to rendering onto the screen.\n"
"fn (i: ^Image) removeRenderTarget*(cam: rect.Rect) {\n"
"\timgremoverendertarget(i^, &cam)\n"
"}\n"
"",
"// Module for getting keyboard and mouse input.\n"
"// Keycodes are ascii chars (lower case) and the constants below.\n"
"//   mouse1\n"
"//   mouse2\n"
"//   mouse3\n"
"//   key_shift\n"
"//   key_backspace\n"
"//   key_delete\n"
"//   key_left\n"
"//   key_right\n"
"//   key_up\n"
"//   key_down\n"
"//   key_escape\n"
"//   key_enter\n"
"// \n"
"// is* functions return info based on a us QWERTY layout. They are supposed to\n"
"// be used for game controls. For text input use getStr.\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"rect.um\"\n"
")\n"
"\n"
"const (\n"
"\tmouse1* =        char(1)\n"
"\tmouse2* =        char(2)\n"
"\tmouse3* =        char(3)\n"
"\tmouse_up* =      char(4)\n"
"\tmouse_down* =    char(5)\n"
"\tkey_shift* =     char(16   + 0x7f)\n"
"\tkey_backspace* = char(8    + 0x7f)\n"
"\tkey_delete* =    char(46   + 0x7f)\n"
"\tkey_left* =      char(37   + 0x7f)\n"
"\tkey_right* =     char(39   + 0x7f)\n"
"\tkey_up* =        char(38   + 0x7f)\n"
"\tkey_down* =      char(40   + 0x7f)\n"
"\tkey_escape* =    char(27   + 0x7f)\n"
"\tkey_enter* =     char(13   + 0x7f)\t\n"
"\tkey_alt* =       char(0x12 + 0x7f)\n"
"\tkey_ctrl* =      char(0x11 + 0x7f)\n"
")\n"
"\n"
"fn cgetmouse(out: ^th.Vf2)\n"
"\n"
"// Returns the position of mouse cursor in relation to the screen.\n"
"fn getMousePos*(): th.Vf2 {\n"
"\tout := th.Vf2{}\n"
"\tcgetmouse(&out)\n"
"\treturn out\n"
"}\n"
"\n"
"// Returns the position of mouse cursor in relation to cam.\n"
"fn getGlobalMousePos*(cam: rect.Rect): th.Vf2 {\n"
"\treturn cam.toWorld(getMousePos())\n"
"}\n"
"\n"
"fn cispressed(keycode: char): int32\n"
"fn cisjustpressed(key: char): int32\n"
"fn cisjustreleased(key: char): int32\n"
"\n"
"// Returns true if key is pressed. Either use codes defined in the file above,\n"
"// or pass lower case char/number.\n"
"fn isPressed*(code: char): bool {\n"
"\tval := bool(cispressed(code))\n"
"\treturn val\n"
"}\n"
"\n"
"// Returns, whether code was just pressed this loop.\n"
"fn isJustPressed*(code: char): bool {\n"
"\treturn bool(cisjustpressed(code))\n"
"}\n"
"\n"
"// Returns true if a key was just released.\n"
"fn isJustReleased*(code: char): bool {\n"
"\treturn bool(cisjustreleased(code))\n"
"}\n"
"\n"
"fn cclear*(code: char)\n"
"// Clears both the pressed and justPressed state of a code.\n"
"fn clear*(code: char) {\n"
"\tcclear(code)\n"
"}\n"
"\n"
"fn cgetinputstring(): str\n"
"// Returns a string entered by the user in the last cycle.\n"
"fn getStr*(): str {\n"
"\treturn cgetinputstring()\n"
"}\n"
"",
"// Misc functions.\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"std.um\"\t\t\t\t\t\t\t\n"
")\n"
"\n"
"// Reads file content into a string.\n"
"fn readall*(path: str): str {\n"
"\tf := std.fopen(path, \"r\")\n"
"\tconst blockSize = 16\n"
"\tres := \"\"\n"
"\n"
"\tfor ok := true; ok {\n"
"\t  var buff: [blockSize + 1]char\n"
"\t  ok = std.fread(f, ^[blockSize]char(&buff)) == 1\n"
"\t  res += str([]char(buff))\n"
"\t}\n"
"\n"
"\tstd.fclose(f)\n"
"\treturn res\n"
"}\n"
"\n"
"// Snaps a value to step.\n"
"fn stepify*(val, step: th.fu): th.fu {\n"
"\tif step != 0 {\n"
"\t\tval = trunc(val / step + 0.5) * step\n"
"\t}\n"
"\treturn val\n"
"}\n"
"",
"// Canvas library allowing for drawing basic shapes. Coordinates are based on\n"
"// the screen.\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"rect.um\"\n"
")\n"
"\n"
"// Draws a basic pixel text. Only ascii is supported.\n"
"fn drawText*(text: str, pos: th.Vf2, color: uint32, size: th.fu)\n"
"\n"
"// Returns the size of text taken by an equivalent drawText call.\n"
"fn textSize*(text: str, scale: th.fu): th.Vf2 {\n"
"\tvar w, maxw, h: int\n"
"\tw = 0\n"
"\tmaxw = 0\n"
"\th = 1\n"
"\t\n"
"\tfor i in text {\n"
"\t\tif text[i] == \"\\n\" {\n"
"\t\t\th += 1\n"
"\t\t\tif w > maxw {\n"
"\t\t\t\tmaxw = w\n"
"\t\t\t}\n"
"\n"
"\t\t\tcontinue\n"
"\t\t}\n"
"\n"
"\t\tw++\n"
"\t}\n"
"\n"
"\tif w > maxw {\n"
"\t\tmaxw = w\n"
"\t}\n"
"\n"
"\treturn th.Vf2{maxw * scale * 6 - scale, h * 6 * scale}\n"
"}\n"
"\n"
"// Draws a Rectangle.\n"
"fn drawRect*(color: uint32, r: rect.Rect)\n"
"\n"
"// Draws a line.\n"
"fn drawLine*(color: uint32, b, e: th.Vf2, thickness: th.fu)\n"
"",
"// This module will undergo changes.\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"ent.um\"\n"
"\t\"rect.um\"\n"
"\t\"canvas.um\"\n"
"\t\"tilemap.um\"\n"
")\n"
"\n"
"// Ray type.\n"
"type Ray* = struct {\n"
"\tpos: th.Vf2\n"
"\tl: th.fu // length\n"
"\tr: th.fu // rotation\n"
"}\n"
"\n"
"// Makes a ray.\n"
"fn mk*(pos: th.Vf2, l: th.fu, r: th.fu = 0.0): Ray {\n"
"\treturn Ray{pos, l, r}\n"
"}\n"
"\n"
"fn craygetcoll(colls: ^ent.Coll, count: ^int, maxCount,\n"
"\tsceneLen: int, r: ^Ray, scene: ^^ent.Ent)\n"
"fn craygettmapcoll(r: ^Ray, t: ^tilemap.Tilemap, ic: ^th.Vf2): bool\n"
"\n"
"// Same as ent.getcoll. Same changes will apply.\n"
"fn (r: ^Ray) getColl*(s: []^ent.Ent, maxColls: th.uu): []ent.Coll {\n"
"\tif len(s) == 0 {\n"
"\t\treturn []ent.Coll{}\n"
"\t}\n"
"\n"
"\tif maxColls > len(s) {\n"
"\t\tmaxColls = len(s)\n"
"\t}\n"
"\n"
"\tcolls := make([]ent.Coll, maxColls)\n"
"\tcount := 0\n"
"\tcraygetcoll(&colls[0], &count, maxColls, len(s), r, &s[0])\n"
"\treturn slice(colls, 0, count)\n"
"}\n"
"\n"
"// Gets ray\'s collision to a tilemap.\n"
"fn (r: ^Ray) getTilemapColl*(t: tilemap.Tilemap, ic: ^th.Vf2): bool {\n"
"\treturn craygettmapcoll(r, &t, ic)\n"
"}\n"
"\n"
"fn (r: ^Ray) draw*(cam: rect.Rect, color: uint32, thickness: th.fu) {\n"
"\tp1 := cam.toScreen(r.pos)\n"
"\tp2 := cam.toScreen(r.pos.add(th.Vf2{0, r.l}.rotated(th.Vf2{}, r.r)))\n"
"\tcanvas.drawLine(color, p1, p2, thickness)\n"
"}\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\t\n"
")\n"
"\n"
"// A set of points representing a rectangle.\n"
"type Rect* = struct {\n"
"\tx, y, w, h: th.fu\n"
"}\n"
"\n"
"fn mk*(x, y, w, h: th.fu): Rect {\n"
"\tvar r: Rect\n"
"\n"
"\tr.x = x\n"
"\tr.y = y\n"
"\tr.w = w\n"
"\tr.h = h\n"
"\n"
"\treturn r\n"
"}\n"
"\n"
"// translates screen coordinates to world coordinates with cam r\n"
"fn (r: ^rect.Rect) toWorld*(p: th.Vf2): th.Vf2 {\n"
"\treturn th.Vf2{ p.x + r.x - r.w/2, p.y + r.y - r.h/2 }\n"
"}\n"
"\n"
"// translates world coordinates to screen coordinates with cam r\n"
"fn (r: ^rect.Rect) toScreen*(p: th.Vf2): th.Vf2 {\n"
"\treturn th.Vf2{ p.x - r.x + r.w/2, p.y - r.y + r.h/2 }\n"
"}\n"
"\n"
"fn (r: ^rect.Rect) getPos*(): th.Vf2 {\n"
"\treturn th.Vf2{r.x, r.y}\n"
"}\n"
"\n"
"fn (r: ^rect.Rect) getDims*(): th.Vf2 {\n"
"\treturn th.Vf2{r.w, r.h}\n"
"}\n"
"\n"
"// returns where the second point of the rectangle lies.\n"
"fn (r: ^rect.Rect) getEnd*(): th.Vf2 {\n"
"\treturn th.Vf2{r.x+r.w, r.y+r.h}\n"
"}\n"
"\n"
"fn ctransformrect(ret: ^th.Quad, r: ^rect.Rect, t: ^th.Transform)\n"
"// Transforms a rect into a quad.\n"
"// Order:\n"
"// \t1. scale\n"
"// \t2. rotation\n"
"// \t3. position\n"
"fn (r: ^rect.Rect) transformed*(t: th.Transform): th.Quad {\n"
"\tvar ret: th.Quad\n"
"\tctransformrect(&ret, r, &t)\n"
"\n"
"\treturn ret\n"
"}\n"
"",
"// Tilemaps allow for easy level construction and fast collisions. You can even\n"
"// use them for some games instead of entities (tetris comes to mind)\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"rect.um\"\n"
"\t\"ent.um\"\n"
"\t\"atlas.um\"\n"
")\n"
"\n"
"const (\n"
"\ttop* = 1\n"
"\tright* = 2\n"
"\tbot* = 4\n"
"\tleft* = 8\n"
")\n"
"\n"
"// Tilemap struct\n"
"type Tilemap* = struct {\n"
"\tatlas: atlas.Atlas\n"
"\tpos: th.Vf2\n"
"\tw: th.uu // width of tilemap\n"
"\tcells: []th.uu // all cells (this will draw the tile in tiles with number in cells - 1)\n"
"\tcollMask: []bool // if true, the tile collides\n"
"\tscale: th.fu\n"
"}\n"
"\n"
"fn mk*(cells: []th.uu, w: th.uu, at: atlas.Atlas, scale: th.fu = 1): Tilemap {\n"
"\tt := Tilemap{}\n"
"\tt.cells = cells\n"
"\tt.w = w\n"
"\tt.atlas = at\n"
"\tt.collMask = make([]bool, 10) //  TODO\n"
"\tt.scale = scale\n"
"\t\n"
"\treturn t\n"
"}\n"
"\n"
"// Sets tile at [x, y] to tile.\n"
"fn (t: ^Tilemap) edit*(x, y, tile: int) {\n"
"\tt.cells[y*t.w + x] = tile\n"
"}\n"
"\n"
"fn cdrawtmap(ct: ^Tilemap, cam: ^rect.Rect)\n"
"\n"
"// Draws the tilemap.\n"
"fn (t: ^Tilemap) draw*(cam: rect.Rect) {\n"
"\tif len(t.cells) == 0 { return }\n"
"\n"
"\tcdrawtmap(t, &cam)\n"
"}\n"
"\n"
"fn ctmapgetcoll(pos: ^th.Vf2, vert: ^th.uu, t: ^Tilemap, e: ^ent.Ent): int32\n"
"\n"
"// Checks, if t collides with e.\n"
"// pos is the tile index where the collision happened\n"
"// vert is which index collided\n"
"// You need to pass a valid pointer (TODO)\n"
"fn (t: ^Tilemap) getColl*(e: ent.Ent, vert: ^th.uu, pos: ^th.Vf2): bool {\n"
"\tif len(t.cells) == 0 { return false }\n"
"\n"
"\tc := ctmapgetcoll(pos, vert, t, &e)\n"
"\n"
"\treturn bool(c)\n"
"}\n"
"\n"
"fn cautotile(tgt: ^th.uu, w, h: th.uu, src, cfg: ^th.uu, tile: th.uu)\n"
"\n"
"// Autotile turns all `tile` tiles in `src` into tiles in `tileCfg`, so they\n"
"// follow up correctly. `tileCfg` is an array of 16 tiles. They are placed in\n"
"// a way where OR of all the places where the tile continues (top, right bot,\n"
"// right). The constants for them are defined in this file. Example:\n"
"// tileCfg[top | bot] = 21\n"
"// top | bot would look something like this: |\n"
"fn (t: ^Tilemap) autotile*(src, tileCfg: []th.uu, tile: th.uu) {\n"
"\tif len(tileCfg) < 16 {\n"
"\t\terror(\"autotile: tileCfg len isn\'t 16\'\")\n"
"\t}\n"
"\n"
"\tcautotile(&t.cells[0], t.w, len(t.cells)/t.w, &src[0], &tileCfg[0], tile)\n"
"}\n"
"",
"// variables:\n"
"// w and h: the dimensions of the window\n"
"// fpsLimit: the fpsLimit\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"canvas.um\"\n"
"\t\"rect.um\"\n"
"\t\"std.um\"\n"
"\t\"images.um\"\n"
")\n"
"\n"
"var (\n"
"\tstart, end, clockOffset: real\n"
"\tw*, h*: int32\n"
"\tfpsLimit*: int = 60\n"
")\n"
"\n"
"fn wsetup(title: str, w, h: int)\n"
"fn clearframe()\n"
"fn getdimensions(w, h: ^int32)\n"
"fn swapbuffers()\n"
"fn handleinput(): bool\n"
"fn updatescaling(w, h, camw, camh: int32)\n"
"fn sleep(ms: int)\n"
"\n"
"// Sets up the engine and opens a window.\n"
"fn setup*(title: str = \"tophat game\", width: int = 400, height: int32 = 400) {\n"
"\tw, h = width, height\n"
"\twsetup(title, width, height)\n"
"\tclearframe()\n"
"\n"
"\tif std.getenv(\"HOME\") == \"\" {\n"
"\t\tth.platform = \"windows\"\n"
"\t}\n"
"\n"
"\tupdatescaling(width, height, width, height)\n"
"\n"
"\timages.init()\n"
"\n"
"\tclockOffset = std.clock() * 1000\n"
"\tstart = std.clock() * 1000\n"
"}\n"
"\n"
"// Cycle needs to be called every cycle. Pass the currently used camera, which\n"
"// i used to calculate tophat\'s scaling. It returns true, if the window is\n"
"// still running.\n"
"fn cycle*(cam: rect.Rect): bool {\n"
"\tcanvas.drawRect(th.black, rect.Rect{0, -h, w, h})\n"
"\tcanvas.drawRect(th.black, rect.Rect{-w, 0, w, h})\n"
"\tcanvas.drawRect(th.black, rect.Rect{0, cam.h, w, h})\n"
"\tcanvas.drawRect(th.black, rect.Rect{cam.w, 0, w, h})\n"
"\tswapbuffers()\n"
"\n"
"\tend = std.clock()*1000\n"
"\tth.delta = round(end - start)\n"
"\tif 1000/fpsLimit - th.delta > 0 {\n"
"\t\tsleep(1000/fpsLimit - th.delta)\n"
"\t\tth.delta = round(std.clock()*1000 - start)\n"
"\t}\n"
"\n"
"\tstart = std.clock()*1000\n"
"\tth.time = round(start - clockOffset)\n"
"\n"
"\trunning := handleinput()\n"
"\tclearframe()\n"
"\tgetdimensions(&w, &h)\n"
"\n"
"\tupdatescaling(w, h, round(cam.w), round(cam.h))\n"
"\treturn running\n"
"}\n"
"\n"
"fn umth_window_begin_scissor(x, y: int, w, h: uint)\n"
"fn umth_window_end_scissor()\n"
"// Disable rendering outside of rect `r`\n"
"fn beginScissorRect*(r: rect.Rect) {\n"
"\tumth_window_begin_scissor(trunc(r.x), trunc(r.y), trunc(r.w), trunc(r.h))\n"
"}\n"
"\n"
"// Stops cropping\n"
"fn endScissor*() {\n"
"\tumth_window_end_scissor();\n"
"}\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"utf8.um\"\n"
"\t\"rect.um\"\n"
"\t\"input.um\"\n"
"\t\"canvas.um\"\n"
")\n"
"\n"
"const (\n"
"\teventUnknown* = 0\n"
"\teventHover*\n"
"\teventPress*\n"
"\teventJustPress*\n"
"\teventRelease*\n"
")\n"
"\n"
"type Theme* = struct {\n"
"\tfg, bg: uint32\n"
"\n"
"\tborderColor: uint32\n"
"\tborderSize: th.fu\n"
"}\n"
"\n"
"// A structure all elements have to contain. t can be set manually by the user,\n"
"// s being the dimensions, or it can be set by another elements. onEvent is an\n"
"// event callback. It will pass whatever is set in the ctx field.\n"
"// Event types:\n"
"// eventUnknown\n"
"// eventHover\n"
"// eventPress\n"
"// eventJustPress\n"
"// eventRelease\n"
"type Generic* = struct {\n"
"\tr: rect.Rect\n"
"\tgridPos: th.Vf2\n"
"\tgridSpan: th.Vf2\n"
"\ttheme: Theme\n"
"\n"
"\tctx: interface{}\n"
"\tonEvent: fn(eventType: th.uu, ctx: interface{})\n"
"\tpressed: bool\n"
"\tselected: bool\n"
"}\n"
"\n"
"// An interface every ui element has to implements.\n"
"type Element* = interface {\n"
"\thandle()\n"
"\tdraw()\n"
"\tget(): ^Generic\n"
"}\n"
"\n"
"// Interface used anywhere, where text is rendered.\n"
"type TextRenderer* = interface {\n"
"\tdraw(text: str, pos: th.Vf2, color: uint32, scale: th.fu = 1.0)\n"
"\tmeasure(text: str): th.Vf2\n"
"}\n"
"\n"
"// Bindings around canvas\'s font rendering functions to make them usable\n"
"// with the TextRenderer interface.\n"
"type PixelFont* = struct { }\n"
"fn (pf: ^PixelFont) draw*(text: str, pos: th.Vf2, color: uint32, scale: th.fu = 1.0) {\n"
"\tcanvas.drawText(text, pos, color, scale)\n"
"}\n"
"fn (pf: ^PixelFont) measure*(text: str): th.Vf2 {\n"
"\treturn canvas.textSize(text, 1)\n"
"}\n"
"\n"
"fn mkGeneric*(): Generic {\n"
"\tg := Generic{}\n"
"\tg.onEvent = fn(eventType: th.uu, ctx: interface{}) { }\n"
"\treturn g\n"
"}\n"
"\n"
"// Functions that sets the grid pos of a Generic\n"
"fn (g: ^Generic) grid*(x, y: th.uu): ^Generic {\n"
"\tg.gridPos.x = x\n"
"\tg.gridPos.y = y\n"
"\treturn g\n"
"}\n"
"\n"
"// Function setting the grid span of a Generic\n"
"fn (g: ^Generic) span*(x, y: th.uu): ^Generic {\n"
"\tg.gridSpan.x = x\n"
"\tg.gridSpan.y = y\n"
"\treturn g\n"
"}\n"
"\n"
"// Generic\'s handle function. It checks for events. If you create your own\n"
"// ui element and want to have more control over how events are fired, you\n"
"// don\'t have to use it.\n"
"fn (g: ^Generic) handle*() {\n"
"\tm := input.getMousePos()\n"
"\tif m.x < g.r.x || m.y < g.r.y ||\n"
"\t\tm.x > g.r.x + g.r.w || m.y > g.r.y + g.r.h {\n"
"\t\tif g.pressed {\n"
"\t\t\tg.pressed = false\n"
"\t\t\tg.onEvent(eventRelease, g.ctx)\n"
"\t\t}\n"
"\t\treturn\n"
"\t}\n"
"\t\n"
"\tg.onEvent(eventHover, g.ctx)\n"
"\t\n"
"\tif input.isPressed(input.mouse1) {\n"
"\t\tinput.clear(input.mouse1)\n"
"\n"
"\t\tif !g.pressed {\n"
"\t\t\tg.onEvent(eventJustPress, g.ctx)\n"
"\t\t}\n"
"\n"
"\t\tg.onEvent(eventPress, g.ctx)\n"
"\t\tg.pressed = true\n"
"\t} else if g.pressed {\n"
"\t\tg.pressed = false\n"
"\t\tg.onEvent(eventRelease, g.ctx)\n"
"\t}\n"
"}\n"
"\n"
"fn drawBorder*(p, d: th.Vf2, t: Theme) {\n"
"\tcanvas.drawRect(t.borderColor, rect.mk(p.x, p.y, t.borderSize, d.y))\n"
"\tcanvas.drawRect(t.borderColor, rect.mk(p.x, p.y, d.x, t.borderSize))\n"
"\tcanvas.drawRect(t.borderColor, rect.mk(p.x + d.x - t.borderSize, p.y, t.borderSize, d.y))\n"
"\tcanvas.drawRect(t.borderColor, rect.mk(p.x, p.y + d.y - t.borderSize, d.x, t.borderSize))\n"
"}\n"
"",
"// Umka standard library\n"
"\n"
"// Memory\n"
"\n"
"fn rtlmemcpy(dest, src: ^void, count: int)\n"
"\n"
"fn tobytes*(buf: interface{}): []uint8 {\n"
"    if buf.__self == null {\n"
"        error(\"Buffer is null\")\n"
"    }\n"
"    if selfhasptr(buf) {\n"
"        error(\"Cannot access reference types\")\n"
"    }\n"
"    bytes := make([]uint8, sizeofself(buf))\n"
"    rtlmemcpy(&bytes[0], buf.__self, sizeofself(buf))\n"
"    return bytes\n"
"}\n"
"\n"
"fn frombytes*(buf: interface{}, bytes: []uint8) {\n"
"    if buf.__self == null {\n"
"        error(\"Buffer is null\")\n"
"    }    \n"
"    if selfhasptr(buf) {\n"
"        error(\"Cannot access reference types\")\n"
"    }\n"
"    if sizeofself(buf) != len(bytes) {\n"
"        error(\"Illegal buffer size\")\n"
"    }\n"
"    rtlmemcpy(buf.__self, &bytes[0], sizeofself(buf))    \n"
"}\n"
"\n"
"// File I/O\n"
"\n"
"type File* = ^struct {}\n"
"\n"
"const (\n"
"    seekBegin* = 0\n"
"    seekCur*   = 1\n"
"    seekEnd*   = 2\n"
")    \n"
"\n"
"fn rtlfopen  (name: str, mode: str): File;  \n"
"fn fopen*    (name: str, mode: str): File {return rtlfopen(name, mode)}\n"
"\n"
"fn rtlfclose (f: File): int\n"
"fn fclose*   (f: File): int {return rtlfclose(f)}\n"
"\n"
"fn rtlfread(buf: ^void, size, cnt: int, f: File): int\n"
"\n"
"fn fread*(f: File, buf: interface{}): int {\n"
"    if f == null {\n"
"        error(\"File is null\")\n"
"    }\n"
"    if bytes := ^[]uint8(buf); bytes != null {\n"
"        return rtlfread(&bytes[0], len(bytes^), 1, f)\n"
"    }\n"
"    if selfhasptr(buf) {\n"
"        error(\"Cannot read reference types except ^[]uint8\")\n"
"    }\n"
"    return rtlfread(buf.__self, sizeofself(buf), 1, f)\n"
"}\n"
"\n"
"fn rtlfwrite(buf: ^void, size, cnt: int, f: File): int\n"
"\n"
"fn fwrite*(f: File, buf: interface{}): int {\n"
"    if f == null {\n"
"        error(\"File is null\")\n"
"    }\n"
"    if bytes := ^[]uint8(buf); bytes != null {\n"
"        return rtlfwrite(&bytes[0], len(bytes^), 1, f)\n"
"    }    \n"
"    if selfhasptr(buf) {\n"
"        error(\"Cannot write reference types except ^[]uint8\")\n"
"    }\n"
"    return rtlfwrite(buf.__self, sizeofself(buf), 1, f)\n"
"}\n"
"\n"
"fn rtlfseek  (f: File, offset, origin: int): int\n"
"fn fseek*    (f: File, offset, origin: int): int {\n"
"    if f == null {\n"
"        error(\"File is null\")\n"
"    }\n"
"    return rtlfseek(f, offset, origin)\n"
"}\n"
"\n"
"fn rtlftell (f: File): int\n"
"fn ftell*   (f: File): int {\n"
"    if f == null {\n"
"        error(\"File is null\")\n"
"    }\n"
"    return rtlftell(f)\n"
"}\n"
"\n"
"fn rtlremove (name: str): int\n"
"fn remove*   (name: str): int {return rtlremove(name)}\n"
"\n"
"fn rtlfeof  (f: File): int\n"
"fn feof*    (f: File): bool {\n"
"    if f == null {\n"
"        error(\"File is null\")\n"
"    }                \n"
"    return bool(rtlfeof(f))\n"
"}\n"
"\n"
"// I/O utilities\n"
"\n"
"fn println*(s: str): int {return printf(\"%s\\n\", s)}\n"
"fn fprintln*(f: File, s: str): int {return fprintf(f, \"%s\\n\", s)}\n"
"\n"
"fn getchar*(): char {\n"
"    var c: char\n"
"    scanf(\"%c\", &c)\n"
"    return c\n"
"}\n"
"\n"
"// Strings\n"
"\n"
"fn ltrim*(s: str): str {\n"
"    start := -1\n"
"    slen := len(s)\n"
"    for i := 0; i < slen; i++ {\n"
"        if s[i] != \' \' && s[i] != \'\\t\' {\n"
"            start = i\n"
"            break\n"
"        } \n"
"    }\n"
"    if start == -1 {return \"\"}\n"
"    return slice(s, start)\n"
"}\n"
"\n"
"fn rtrim*(s: str): str {\n"
"    stop := -1\n"
"    slen := len(s)\n"
"    for i := slen - 1; i >= 0; i-- {\n"
"        if s[i] != \' \' && s[i] != \'\\t\' {\n"
"            stop = i\n"
"            break\n"
"        } \n"
"    }\n"
"    if stop == -1 {return \"\"}\n"
"    return slice(s, 0, stop + 1)\n"
"}\n"
"\n"
"fn trim*(s: str): str {\n"
"    return ltrim(rtrim(s))\n"
"}\n"
"\n"
"// Conversions\n"
"\n"
"fn atoi*(s: str): int {\n"
"    var x: int\n"
"    sscanf(s, \"%lld\", &x)\n"
"    return x\n"
"}\n"
"\n"
"fn atof*(s: str): real {\n"
"    var x: real\n"
"    sscanf(s, \"%lf\", &x)\n"
"    return x\n"
"}\n"
"\n"
"fn itoa*(x: int): str {\n"
"    s := str(make([]char, 256))\n"
"    sprintf(s, \"%lld\", x)\n"
"    return s\n"
"}\n"
"\n"
"fn ftoa*(x: real, decimals: int): str {\n"
"    fmt := str(make([]char, 256))\n"
"    s := str(make([]char, 256))\n"
"    sprintf(fmt, \"%%.%dlf\", decimals)\n"
"    sprintf(s, fmt, x)\n"
"    return s\n"
"}\n"
"\n"
"// Math\n"
"\n"
"const pi* = 3.14159265358979323846\n"
"\n"
"// Random numbers\n"
"\n"
"const randMax* = 0x7FFFFFFF\n"
"randSeed := 0\n"
"\n"
"fn srand*(seed: int) {randSeed = seed}\n"
"\n"
"fn rand*(): int {\n"
"    randSeed = ((randSeed * 1103515245) + 12345) & 0x7FFFFFFF\n"
"    return randSeed\n"
"}\n"
"\n"
"fn frand*(): real {return real(rand()) / randMax}\n"
"\n"
"// Timer\n"
"\n"
"fn rtltime(): int\n"
"fn time*(): int {return rtltime()}\n"
"\n"
"fn rtlclock(): real\n"
"fn clock*(): real {return rtlclock()}\n"
"\n"
"// Command line and environment\n"
"\n"
"fn argc*(): int {return rtlargc}\n"
"\n"
"fn argv*(i: int): str {\n"
"    if i < 0 || i >= rtlargc {\n"
"        error(\"Command line parameter not found\")\n"
"    }\n"
"    return rtlargv[i]\n"
"}\n"
"\n"
"fn rtlgetenv(name: str): str\n"
"fn getenv*(name: str): str {\n"
"    return \"\" + rtlgetenv(name)\n"
"}\n"
"\n"
"",
"// Particles allow for <i>performant</i> and random particle systems.\n"
"// TODO: a better constructor\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"rect.um\"\n"
")\n"
"\n"
"// Particle struct. You can tweak the start_time for godot-like explossivness.\n"
"type Particle* = struct {\n"
"\tstart_time: uint\n"
"\tseed: int32\n"
"}\n"
"\n"
"// Emitter. This is where everything is configured.\n"
"type Emitter* = struct {\n"
"\tpos: th.Vf2 // position\n"
"\tdm: th.Vf2 // size of the emittion area\n"
"\tgravity: th.Vf2 // gravity\n"
"\trepeat: bool // if false, particle won\'t be renewed\n"
"\tactive: bool // false, if there aren\'t any active particles anymore\n"
"\t\n"
"\tangle: th.Vf2 // angle in which particles are emitted\n"
"\n"
"\tlifetime: th.uu // lifetime of particles\n"
"\tlifetimeRandomness: th.fu // randomness in %/100\n"
"\n"
"\tvelocity: th.fu // velocity\n"
"\tvelocityRandomness: th.fu // randomness in %/100\n"
"\n"
"\tsize: th.fu // size\n"
"\tsizeRandomness: th.fu // randomness in %/100\n"
"\tmaxSize: th.fu // size at the end of particles lifetime\n"
"\n"
"\trotation: th.fu\n"
"\trotationRandomness: th.fu\n"
"\tmaxRotation: th.fu\n"
"\n"
"\tcolors: []uint32 // array of colors, which are interpolated between\n"
"\t\n"
"\tparticles: []Particle // list of particles\n"
"}\n"
"\n"
"fn c_particles_draw(p: ^Emitter, cam: ^rect.Rect, t: int32)\n"
"\n"
"// Draws and updates the particles.\n"
"fn (e: ^Emitter) draw*(cam: rect.Rect, t: int32) {\n"
"\tif len(e.colors) <= 0 || len(e.particles) <= 0 {\n"
"\t\treturn\n"
"\t}\n"
"\n"
"\tc_particles_draw(e, &cam, t)\n"
"}\n"
"",
"// <b>TO BE DELETED</b>\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"rect.um\"\n"
")\n"
"\n"
"// Mask is a set of dots that can be edited and drawn to emulate light.\n"
"// You can even edit the dots yourself, but it won\'t look good with multiple\n"
"// lights. A function for plotting a pixel will be available soon.\n"
"type Mask* = struct {\n"
"\tdots: []uint32\n"
"\tw, h: th.uu\n"
"\trectSize: th.fu\n"
"\tcolor: uint32\n"
"}\n"
"\n"
"type cmask = struct {\n"
"\tdots: ^uint32\n"
"\tw, h: th.uu\n"
"\trectsize: th.fu\n"
"\tcolor: uint32\n"
"}\n"
"\n"
"// A circular light that can be plotted onto a mask.\n"
"type Spotlight* = struct {\n"
"\tpos: th.Vf2\n"
"\tradius: th.uu\n"
"\ttint: uint32\n"
"}\n"
"\n"
"fn clightmaskclear(m: ^cmask)\n"
"\n"
"// Clears the lightmask to have it\'s own default color.\n"
"fn (m: ^Mask) clear*() {\n"
"\tcm := cmask {\n"
"\t\t&m.dots[0],\n"
"\t\tm.w, m.h, m.rectSize,\n"
"\t\tm.color}\n"
"\n"
"\tclightmaskclear(&cm)\n"
"}\n"
"\n"
"fn mk*(color: uint32, rectSize: real, cam: rect.Rect): Mask {\n"
"\td := Mask{}\n"
"\n"
"\td.rectSize = rectSize\n"
"\td.w = round(cam.w / rectSize)\n"
"\td.h = round(cam.h / rectSize)\n"
"\td.dots = make([]uint32, d.w * d.h)\n"
"\td.color = color\n"
"\n"
"\td.clear()\n"
"\n"
"\treturn d\n"
"}\n"
"\n"
"fn clightmaskdraw(m: ^cmask, cam: ^rect.Rect)\n"
"\n"
"// Draws a lightmask.\n"
"fn (m: ^Mask) draw*(cam: rect.Rect) {\n"
"\tcm := cmask {\n"
"\t\t&m.dots[0],\n"
"\t\tm.w, m.h, m.rectSize,\n"
"\t\tm.color}\n"
"\n"
"\tclightmaskdraw(&cm, &cam)\n"
"}\n"
"\n"
"fn cspotlightstamp(s: ^Spotlight, m: ^cmask, cam: ^rect.Rect)\n"
"\n"
"// Stamps a spotlight onto a mask.\n"
"fn (s: ^Spotlight) stamp*(m: ^Mask, cam: rect.Rect) {\n"
"\tcm := cmask {\n"
"\t\t&m.dots[0],\n"
"\t\tm.w, m.h, m.rectSize,\n"
"\t\tm.color}\n"
"\n"
"\tcspotlightstamp(s, &cm, &cam)\n"
"}\n"
"\n"
"",
"// Simple linear interpolation module.\n"
"\n"
"import (\n"
"\t\"th.um\"\t\t\t\t\t\t\t\t\n"
")\n"
"\n"
"type Any* = interface{}\n"
"\n"
"// Lerper queue item. It interpolates between start and end for the duration\n"
"// of length in ms. Additionally you can enable swap, which instead of\n"
"// dequeueing swaps start and end and resets the progress.\n"
"type Item* = struct {\n"
"\tstart, end: th.fu\n"
"\tlength: th.uu\n"
"\tprogress: th.fu\n"
"\tswap: bool\n"
"\tctx: Any\n"
"\tcallback: fn(ctx: Any)\n"
"}\n"
"\n"
"// Item\'s constructor\n"
"fn mk*(start, end: th.fu, length: th.uu, swap: bool = false): Item {\n"
"\treturn Item{\n"
"\t\tstart, end, length, 0, swap, null, fn(ctx: Any) {}}\n"
"}\n"
"\n"
"// Lerper is a queue of items. It will lerp the first one and if it ends\n"
"// and doesn\'t have swap enabled, it will dequeue it.\n"
"type Lerper* = []Item\n"
"\n"
"// Removes the first lerper item.\n"
"fn (l: ^Lerper) dequeue*() {\n"
"\tswitch len(l^) {\n"
"\tcase 0:\n"
"\t\treturn\n"
"\tcase 1:\n"
"\t\tl^ = Lerper{}\n"
"\tdefault:\n"
"\t\tl^ = slice(l^, 1)\n"
"\t}\n"
"}\n"
"\n"
"// Adds an item to l\'s queue\n"
"fn (l: ^Lerper) enqueue*(i: Item) {\n"
"\tl^ = append(l^, i)\n"
"}\n"
"\n"
"// Interpolates the front by delta. And returns it\'s value.\n"
"fn (l: ^Lerper) byDelta*(delta: th.uu): th.fu {\n"
"\tif len(l^) == 0 {\n"
"\t\treturn 0\n"
"\t}\n"
"\n"
"\t/*for l[0].progress >= 1.0 {\n"
"\t\tl[0].callback(l[0].ctx)\n"
"\n"
"\t\tif l[0].swap {\n"
"\t\t\ttmp := l[0].start\n"
"\t\t\tl[0].start = l[0].end\n"
"\t\t\tl[0].end = tmp\n"
"\n"
"\t\t\tl[0].progress = 0\n"
"\t\t\tbreak\n"
"\t\t}\n"
"\n"
"\t\tl.dequeue()\n"
"\t\tif len(l^) == 0 {\n"
"\t\t\treturn 0\n"
"\t\t}\n"
"\t}*/\n"
"\n"
"\tif l[0].progress >= 1 {\n"
"\t\tend := l[0].end\n"
"\t\tl.dequeue()\n"
"\t\treturn end\n"
"\t}\n"
"\n"
"\tl[0].progress += th.fu(delta)/l[0].length\n"
"\n"
"\treturn l[0].progress * (l[0].end-l[0].start) + l[0].start\n"
"}\n"
"",
"// UTF-8 utilities\n"
"\n"
"type (\n"
"\tRune* = int32\n"
")\n"
"\n"
"fn (r: ^Rune) size*(): int {\n"
"\tif r^ <= 0x7f {\n"
"\t\treturn 1\n"
"\t}\n"
"\n"
"\tif r^ <= 0x7ff {\n"
"\t\treturn 2\n"
"\t}\n"
"\n"
"\tif r^ <= 0xffff {\n"
"\t\treturn 3\n"
"\t}\n"
"\n"
"\tif r^ <= 0x10ffff {\n"
"\t\treturn 4\n"
"\t}\n"
"\n"
"\treturn 0\n"
"}\n"
"\n"
"fn (r: ^Rune) encode*(): str {\n"
"\ts := r.size()\n"
"\n"
"\tif s == 1 {\n"
"\t\treturn str(char(r^))\n"
"\t}\n"
"\n"
"\tout := make([]char, s + 1)\n"
"\n"
"\t// header is size amount of ones at the start\n"
"\theader := 0\n"
"\tfor i := 0; i < s; i++ {\n"
"\t\theader |= 1 << (7 - i)\n"
"\t}\n"
"\n"
"\tshift := (s - 1) * 6\n"
"\tout[0] = char(((r^ >> shift & 0xff) | header) & 0xff)\n"
"\n"
"\tfor i := 1; i < s; i++ {\n"
"\t\tshift -= 6\n"
"\t\tout[i] = char(r^ >> shift & 0x3f | 0x80)\n"
"\t}\n"
"\n"
"\treturn str(out)\n"
"}\n"
"\n"
"fn getNextRune*(a: str, pos: int): Rune\n"
"\n"
"fn decode*(s: str): []Rune {\n"
"\trunes := make([]Rune, len(s))\n"
"\truneCount := 0\n"
"\n"
"\tl := len(s)\n"
"\t\n"
"\tfor i := 0; i < l; runeCount++ {\n"
"\t\trunes[runeCount] = getNextRune(s, i)\n"
"\t\ti += runes[runeCount].size()\n"
"\t}\n"
"\n"
"\treturn slice(runes, 0, runeCount)\n"
"}\n"
"\n"
"fn realLength*(s: str): int {\n"
"\trl := 0\n"
"\tl := len(s)\n"
"\tfor i := 0; i < l; rl++ {\n"
"\t\tr := getNextRune(s, i)\n"
"\t\ti += r.size()\n"
"\t}\n"
"\n"
"\treturn rl\n"
"}\n"
"",
"// Module for font rendering. Unicode is supported, but only left to right.\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
")\n"
"\n"
"const (\n"
"\tfilterBilinear* = 0\n"
"\tfilterNearest* = 1\n"
")\n"
"\n"
"type Font* = struct { _: ^struct{} }\n"
"\n"
"fn cfontload(path: str, size: th.fu, filter: uint32): ^struct{}\n"
"fn cfontdraw(font: Font, s: str, x: th.fu, y: th.fu, color: uint32, scale: th.fu)\n"
"fn cfontmeasure(font: Font, s: str, o: ^th.Vf2)\n"
"\n"
"fn load*(path: str, size: th.fu, filter: uint32 = filterBilinear): Font {\n"
"\treturn Font{cfontload(path, size, filter)}\n"
"}\n"
"\n"
"fn (f: ^Font) draw*(text: str, pos: th.Vf2, color: uint32, scale: th.fu = 1.0) {\n"
"\tcfontdraw(f^, text, pos.x, pos.y, color, scale)\n"
"}\n"
"\n"
"fn (f: ^Font) validate*(): bool {\n"
"\treturn f._ != null\n"
"}\n"
"\n"
"fn (f: ^Font) measure*(text: str): th.Vf2 {\n"
"\tvar size: th.Vf2\n"
"\tcfontmeasure(f^, text, &size)\n"
"\treturn size\n"
"}",
"// Module with useful variables and types.\n"
"// Variables: time, delta, platform\n"
"// Constants: black, white, red, green, blue, yellow, magenta, cyan.\n"
"\n"
"import (\n"
"\t\"std.um\"\n"
")\n"
"\n"
"// standard type for real values\n"
"type fu* = real32\n"
"// standard type for integer values\n"
"type iu* = int32\n"
"// standard type for unsigned values\n"
"type uu* = uint32\n"
"\n"
"// vector 2\n"
"type Vf2* = struct {\n"
"\tx, y: fu\n"
"}\n"
"\n"
"// Vf2 constructor\n"
"fn mkVf2*(x: fu = 0, y: fu = 0): Vf2 {\n"
"\treturn Vf2{x, y}\n"
"}\n"
"\n"
"// rotates `p` around `origin` with `rot` in degrees\n"
"fn (p: ^th.Vf2) rotated*(origin: th.Vf2, rot: th.fu): th.Vf2 {\n"
"\tangle := (rot * std.pi) / 180\n"
"\n"
"\tpos := p^\n"
"\tpos.x -= origin.x\n"
"\tpos.y -= origin.y\n"
"\n"
"\tx := pos.x * cos(angle) - pos.y * sin(angle)\n"
"\ty := pos.x * sin(angle) + pos.y * cos(angle)\n"
"\n"
"\tpos.x = x + origin.x\n"
"\tpos.y = y + origin.y\n"
"\n"
"\treturn pos\n"
"}\n"
"\n"
"// distance between p1 and p2\n"
"fn (p1: ^th.Vf2) distanceTo*(p2: th.Vf2): th.fu {\n"
"\treturn std.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y))\n"
"}\n"
"\n"
"// Angle between p1 and p2\n"
"fn (p1: ^th.Vf2) angleTo*(p2: th.Vf2): real {\n"
"\tif p1.x == p2.x && p1.y == p2.y { return 0 }\n"
"\treturn atan2(p2.y - p1.y, p2.x - p1.x) * 180 / std.pi + 180\n"
"}\n"
"\n"
"// Absolute value of a vector.\n"
"fn (p: ^th.Vf2) abs*(): th.Vf2 {\n"
"\treturn th.Vf2{fabs(p.x), fabs(p.y)}\n"
"}\n"
"\n"
"// Rounds a vector.\n"
"fn (p: ^th.Vf2) round*(): th.Vf2 {\n"
"\treturn th.Vf2{round(p.x), round(p.y)}\n"
"}\n"
"\n"
"// Truncates a vector.\n"
"fn (p: ^th.Vf2) trunc*(): th.Vf2 {\n"
"\treturn th.Vf2{trunc(p.x), trunc(p.y)}\n"
"}\n"
"\n"
"// Floors a vector.\n"
"fn (p: ^th.Vf2) floor*(): th.Vf2 {\n"
"\treturn th.Vf2{floor(p.x), floor(p.y)}\n"
"}\n"
"\n"
"// Ceils a vector.\n"
"fn (p: ^th.Vf2) ceil*(): th.Vf2 {\n"
"\treturn th.Vf2{ceil(p.x), ceil(p.y)}\n"
"}\n"
"\n"
"// Creates a vector with both x and y set to f\n"
"fn vf2f*(f: th.fu): th.Vf2 {\n"
"\treturn th.Vf2{f, f}\n"
"}\n"
"\n"
"// Subtracts a vector from another one.\n"
"fn (p: ^th.Vf2) sub*(p2: th.Vf2): th.Vf2 {\n"
"\treturn th.Vf2{p.x - p2.x, p.y - p2.y}\n"
"}\n"
"\n"
"// Subtracts a fu from a vector.\n"
"fn (p: ^th.Vf2) subf*(f: th.fu): th.Vf2 {\n"
"\treturn th.Vf2{p.x - f, p.y - f}\n"
"}\n"
"\n"
"// Adds a vector to another one.\n"
"fn (p: ^th.Vf2) add*(p2: th.Vf2): th.Vf2 {\n"
"\treturn th.Vf2{p.x + p2.x, p.y + p2.y}\n"
"}\n"
"\n"
"// Adds a fu to a vector.\n"
"fn (p: ^th.Vf2) addf*(f: th.fu): th.Vf2 {\n"
"\treturn th.Vf2{p.x + f, p.y + f}\n"
"}\n"
"\n"
"// Divides a vector by another one.\n"
"fn (p: ^th.Vf2) div*(p2: th.Vf2): th.Vf2 {\n"
"\treturn th.Vf2{p.x / p2.x, p.y / p2.y}\n"
"}\n"
"\n"
"// Divides a vector by a fu.\n"
"fn (p: ^th.Vf2) divf*(f: th.fu): th.Vf2 {\n"
"\treturn th.Vf2{p.x / f, p.y / f}\n"
"}\n"
"\n"
"// Multiplies a vector by another one.\n"
"fn (p: ^th.Vf2) mul*(p2: th.Vf2): th.Vf2 {\n"
"\treturn th.Vf2{p.x * p2.x, p.y * p2.y}\n"
"}\n"
"\n"
"// Multiplies a vector by a fu.\n"
"fn (p: ^th.Vf2) mulf*(f: th.fu): th.Vf2 {\n"
"\treturn th.Vf2{p.x * f, p.y * f}\n"
"}\n"
"\n"
"// Returns the magnitude of a vector p.\n"
"fn (p: ^th.Vf2) mag*(): th.fu {\n"
"\treturn sqrt(p.x * p.x + p.y * p.y)\n"
"}\n"
"\n"
"// Normalizes a vector.\n"
"fn (p: ^th.Vf2) norm*(): th.Vf2 {\n"
"\tif p.x == 0 && p.y == 0 {\n"
"\t\treturn p^\n"
"\t}\n"
"\n"
"\treturn p.divf(p.mag())\n"
"}\n"
"\n"
"// Calculates dot product between 2 vectors.\n"
"fn (p: ^th.Vf2) dot*(q: th.Vf2): fu {\n"
"\treturn p.x*q.x + p.y*q.y\n"
"}\n"
"\n"
"// Struct defining transformation. Used for example by entities.\n"
"type Transform* = struct {\n"
"\tp: Vf2 // position\n"
"\ts: Vf2 // scale\n"
"\to: Vf2 // origin\n"
"\tr: fu  // rotation\n"
"}\n"
"\n"
"// Transform constructor\n"
"fn mkTransform*(p: Vf2, s: Vf2 = Vf2{1, 1}, o: Vf2 = Vf2{0, 0}, r: fu = 0.0): Transform {\n"
"\treturn Transform{p: p, s: s, o: o, r: r}\n"
"}\n"
"\n"
"fn ctransformvf2(v: ^Vf2, t: ^Transform)\n"
"// Transforms a vf2 to another vf2.\n"
"// Order:\n"
"// \t1. scale\n"
"// \t2. rotation\n"
"// \t3. position\n"
"// \n"
"// This allows conversion from a relative to an absolute vf2.\n"
"fn (v: ^Vf2) transformed*(t: Transform): Vf2 {\n"
"\tret := v^\n"
"\tctransformvf2(&ret, &t)\n"
"\treturn ret\n"
"}\n"
"\n"
"type Quad* = [4]th.Vf2\n"
"\n"
"fn ctransformquad(q: ^Quad, t: ^Transform)\n"
"// Transforms a quad into another quad.\n"
"// Order:\n"
"// \t1. scale\n"
"// \t2. rotation\n"
"// \t3. position\n"
"fn (q: ^Quad) transformed*(t: Transform): Quad {\n"
"\tret := q^\n"
"\tctransformquad(&ret, &t)\n"
"\treturn ret\n"
"}\n"
"\n"
"fn cgetglobal(): ^struct{}\n"
"// returns a pointer to the th_global. Set this as your extensions thg.\n"
"fn getGlobal*(): ^struct{} {\n"
"\treturn cgetglobal()\n"
"}\n"
"\n"
"fn cgetfuncs(): ^struct{}\n"
"// returns pointer to tophat functions. Pass this to th_ext_set.\n"
"fn getFuncs*(): ^struct{} {\n"
"\treturn cgetfuncs()\n"
"}\n"
"\n"
"const (\n"
"\tblack* = 0xff\n"
"\twhite* = 0xffffffff\n"
"\tred* = 0xff0000ff\n"
"\tgreen* = 0x00ff00ff\n"
"\tblue* = 0x0000ffff\n"
"\tyellow* = 0xffff00ff\n"
"\tmagenta* = 0xff00ffff\n"
"\tcyan* = 0x00ffffff\n"
")\n"
"\n"
"var (\n"
"\ttime*: uint\n"
"\tdelta*: int\n"
"\tplatform*: str = \"linux\"\n"
")\n"
"",
"// A module for importless communication between modules. A signal is an array\n"
"// of callbacks with a name.\n"
"\n"
"type Any* = interface{}\n"
"type Callback* = fn(ctx: Any) \n"
"type Signal* = []Callback\n"
"\n"
"var signals: map[str]Signal\n"
"\n"
"// Registers a callback to a signal. There is no need to explicitely create\n"
"// signals.\n"
"fn register*(name: str, callback: Callback) {\n"
"\tif !valid(signals) {\n"
"\t\tsignals = make(map[str]Signal)\n"
"\t}\n"
"\n"
"\tif !validkey(signals, name) {\n"
"\t\tsignals[name] = Signal{callback}\n"
"\t} else {\n"
"\t\tsignals[name] = append(signals[name], callback)\n"
"\t}\n"
"}\n"
"\n"
"// Calls all callbacks associated with the passed name.\n"
"fn emit*(name: str, ctx: Any) {\n"
"\tif !valid(signals) {\n"
"\t\tsignals = make(map[str]Signal)\n"
"\t}\n"
"\n"
"\tfor i, c in signals[name] {\n"
"\t\tc(ctx)\n"
"\t}\n"
"}\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"image.um\"\n"
")\n"
"\n"
"// Atlas is an image containing tiles in a square grid.\n"
"type Atlas* = struct {\n"
"\ti: image.Image // source image\n"
"\tcs: th.Vf2 // size of a cell in pixels\n"
"\tdm: th.Vf2 // amount of cells in image\n"
"}\n"
"\n"
"// i: source image\n"
"// dm: amount of cells\n"
"fn mk*(i: image.Image, dm: th.Vf2): Atlas {\n"
"\ta := atlas.Atlas{}\n"
"\n"
"\ta.i = i\n"
"\ta.dm = dm\n"
"\ta.cs = i.getDims().div(dm)\n"
"\n"
"\treturn a\n"
"}\n"
"\n"
"// returns the coordinates of the nth tile\n"
"fn (a: ^Atlas) coords*(n: int): th.Vf2 {\n"
"\treturn th.Vf2{ n % trunc(a.dm.x), (n - n % trunc(a.dm.x)) / a.dm.x }\n"
"}\n"
"\n"
"// Crops the sourse image to only show a wanted tile\n"
"fn (a: ^Atlas) cropSource*(at: th.Vf2) {\n"
"\tif (at.x > a.dm.x || at.y > a.dm.y || at.x * at.y < 0) {\n"
"\t\treturn\n"
"\t}\n"
"\n"
"\ta.i.crop(\n"
"\t\tth.Vf2{at.x / a.dm.x, at.y / a.dm.y},\n"
"\t\tth.Vf2{(at.x+1) / a.dm.x, (at.y+1) / a.dm.y})\n"
"}\n"
"\n"
"// Draws the tile at `at`\n"
"fn (a: ^Atlas) draw*(at: th.Vf2, t: th.Transform) {\n"
"\ta.cropSource(at)\n"
"\ta.i.draw(t, th.white)\n"
"\ta.i.crop(th.Vf2{}, th.Vf2{1, 1})\n"
"}\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"utf8.um\"\n"
"\t\"rect.um\"\n"
"\t\"../ui.um\"\n"
"\t\"canvas.um\"\n"
")\n"
"\n"
"// An element containing a TextRenderer. The text renderer supports\n"
"// word-wrapping and centered text.\n"
"type Label* = struct {\n"
"\tg: ui.Generic\n"
"\ttext: str\n"
"\trenderer: ui.TextRenderer\n"
"\tcenter: bool\n"
"\twrapping: bool\n"
"\tscale: th.fu\n"
"}\n"
"\n"
"// Label constructor\n"
"fn mk*(f: ui.TextRenderer, text: str, theme: ui.Theme, scale: th.fu, center: bool = false, wrapping: bool = false): Label {\n"
"\tl := Label{}\n"
"\tl.g = ui.mkGeneric()\n"
"\tl.g.theme = theme\n"
"\tl.text = text\n"
"\tl.renderer = f\n"
"\tl.scale = scale\n"
"\tl.center = center\n"
"\tl.wrapping = wrapping\n"
"\n"
"\treturn l\n"
"}\n"
"\n"
"fn (l: ^Label) get*(): ^ui.Generic {\n"
"\treturn &l.g\n"
"}\n"
"\n"
"fn (l: ^Label) handle*() {\n"
"\tl.g.handle()\n"
"}\n"
"\n"
"fn (l: ^Label) draw*() {\n"
"\tif len(l.text) == 0 {\n"
"\t\treturn\n"
"\t}\n"
"\n"
"\tcanvas.drawRect(l.g.theme.bg, rect.Rect{l.g.r.x, l.g.r.y, l.g.r.w, l.g.r.h})\n"
"\tui.drawBorder(l.g.r.getPos(), l.g.r.getDims(), l.g.theme)\n"
"\n"
"\ttext := utf8.decode(l.text)\n"
"\t// hack to wrap the last word too\n"
"\ttext = append(text, uint32(\' \'))\n"
"\tlineCount := 1\n"
"\n"
"\tlines := [][]utf8.Rune{}\n"
"\n"
"\tif l.wrapping {\n"
"\t\tlimit := l.g.r.w - l.g.theme.borderSize * 2\n"
"\t\twordStart := 0\n"
"\t\tlineWidth := 0.0\n"
"\n"
"\t\tfor i:=0; i < len(text); i++ {\n"
"\t\t\tif text[i] == uint32(\' \') {\n"
"\t\t\t\tif lineWidth > limit {\n"
"\t\t\t\t\tlines = append(lines, slice(text, 0, wordStart - 1))\n"
"\t\t\t\t\ttext = slice(text, wordStart)\n"
"\n"
"\t\t\t\t\twordStart = 0\n"
"\t\t\t\t\tlineWidth = 0\n"
"\t\t\t\t\ti = -1\n"
"\t\t\t\t\tcontinue\n"
"\t\t\t\t}\n"
"\n"
"\t\t\t\twordStart = i + 1\n"
"\t\t\t\tlineWidth += l.renderer.measure(\" \").x * l.scale\n"
"\t\t\t} else if text[i] == uint32(\'\\n\') {\n"
"\t\t\t\tlines = append(lines, slice(text, 0, i))\n"
"\t\t\t\ttext = slice(text, i + 1)\n"
"\n"
"\t\t\t\twordStart = 0\n"
"\t\t\t\tlineWidth = 0\n"
"\t\t\t\ti = -1\n"
"\t\t\t} else {\n"
"\t\t\t\tlineWidth += l.renderer.measure(text[i].encode()).x * l.scale\n"
"\t\t\t}\n"
"\t\t}\n"
"\n"
"\t\t// we have to remove the space again to prevent alignment issues\n"
"\t\tlines = append(lines, slice(text, 0, len(text) - 1))\n"
"\t} else {\n"
"\t\tlines = append(lines, text)\n"
"\t}\n"
"\n"
"\tx := l.g.r.x + l.g.theme.borderSize\n"
"\ty := l.g.r.y\n"
"\tif l.center {\n"
"\t\ty += (l.g.r.h - len(lines) * l.renderer.measure(\"A\").y * l.scale) / 2\n"
"\t}\n"
"\n"
"\tfor i in lines {\n"
"\t\ts := \"\"\n"
"\t\tfor j in lines[i] {\n"
"\t\t\ts += lines[i][j].encode()\n"
"\t\t}\n"
"\n"
"\t\tp := th.Vf2{\n"
"\t\t\tx: x,\n"
"\t\t\ty: y }\n"
"\n"
"\t\tif l.center {\n"
"\t\t\tp.x += (l.g.r.w - l.renderer.measure(s).x * l.scale) / 2 + l.g.theme.borderSize / 2\n"
"\t\t}\n"
"\n"
"\t\tl.renderer.draw(s, p, l.g.theme.fg, l.scale)\n"
"\n"
"\t\ty += l.renderer.measure(s).y * l.scale\n"
"\t}\n"
"}\n"
"\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"ui.um\"\n"
")\n"
"\n"
"// A Grid container. The grid size is fixed, not dynamic like in Tk.\n"
"type Grid* = struct {\n"
"\tg: ui.Generic\n"
"\tw, h: th.uu\n"
"\tborder: th.fu\n"
"\telements: []ui.Element\n"
"}\n"
"\n"
"// Grid\'s constructor\n"
"fn mk*(w, h: th.uu, border: th.fu = 0): Grid {\n"
"\treturn Grid {\n"
"\t\tg: ui.mkGeneric(),\n"
"\t\tw: w, h: h, border: border}\n"
"}\n"
"\n"
"fn (g: ^Grid) get*(): ^ui.Generic {\n"
"\treturn &g.g\n"
"}\n"
"\n"
"fn (g: ^Grid) handle*() {\n"
"\tcellSize := th.Vf2{g.g.r.w/g.w, g.g.r.h/g.h}\n"
"\n"
"\tfor i:=0; i < len(g.elements); i++ {\n"
"\t\te := &g.elements[i]\n"
"\t\tge := e.get()\n"
"\n"
"\t\tif ge.gridPos.x > g.w || ge.gridPos.y > g.h {\n"
"\t\t\terror(\"ui.Grid: out of bounds.\")\n"
"\t\t}\n"
"\n"
"\t\tge.r.x = ge.gridPos.x * cellSize.x\n"
"\t\tge.r.y = ge.gridPos.y * cellSize.y\n"
"\t\t// divide by to as there are two borders\n"
"\t\tge.r.x += g.border/2 + g.g.r.x\n"
"\t\tge.r.y += g.border/2 + g.g.r.y\n"
"\n"
"\t\tif ge.gridPos.x + ge.gridSpan.x > g.w ||\n"
"\t\t\tge.gridPos.y + ge.gridSpan.y > g.h {\n"
"\t\t\terror(\"ui.Grid: out of bounds.\")\n"
"\t\t}\n"
"\n"
"\t\tif ge.gridSpan.x == 0 {\n"
"\t\t\tge.gridSpan.x = 1\n"
"\t\t}\n"
"\n"
"\t\tif ge.gridSpan.y == 0 {\n"
"\t\t\tge.gridSpan.y = 1\n"
"\t\t}\n"
"\n"
"\t\tge.r.w = ge.gridSpan.x * cellSize.x\n"
"\t\tge.r.h = ge.gridSpan.y * cellSize.y\n"
"\t\t// don\'t divide by two as size is relative to position\n"
"\t\tge.r.w -= g.border\n"
"\t\tge.r.h -= g.border\n"
"\n"
"\t\te.handle()\n"
"\t}\n"
"}\n"
"\n"
"fn (g: ^Grid) draw*() {\n"
"\tfor i, e in g.elements {\n"
"\t\te.draw()\n"
"\t}\n"
"}\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"ui.um\"\n"
"\t\"image.um\"\n"
")\n"
"\n"
"// An element containing an image\n"
"type Image* = struct {\n"
"\tg: ui.Generic\n"
"\timage: image.Image\n"
"\tstretch: bool\n"
"}\n"
"\n"
"fn mk*(i: image.Image, stretch: bool = false): Image {\n"
"\treturn Image {\n"
"\t\tg: ui.Generic{},\n"
"\t\timage: i,\n"
"\t\tstretch: stretch}\n"
"}\n"
"\n"
"fn (i: ^Image) get*(): ^ui.Generic {\n"
"\treturn &i.g\n"
"}\n"
"\n"
"fn (i: ^Image) handle*() {\n"
"\ti.g.handle()\n"
"}\n"
"\n"
"fn (i: ^Image) draw*() {\n"
"\tdm := i.image.getDims()\n"
"\ts := th.Vf2{}\n"
"\tif i.stretch {\n"
"\t\ts.x = i.g.r.w/dm.x\n"
"\t\ts.y = i.g.r.h/dm.y\n"
"\t} else {\n"
"\t\tif i.g.r.w < i.g.r.h {\n"
"\t\t\ts.x = i.g.r.w/dm.x\n"
"\t\t\ts.y = s.x\n"
"\t\t\ti.g.r.y += (i.g.r.h - s.y*dm.y)/2\n"
"\t\t} else {\n"
"\t\t\ts.y = i.g.r.h/dm.y\n"
"\t\t\ts.x = s.y\n"
"\t\t\ti.g.r.x += (i.g.r.w - s.x*dm.x)/2\n"
"\t\t}\n"
"\t}\n"
"\n"
"\ti.image.draw(th.Transform{p: i.g.r.getPos(), s: s}, th.white)\n"
"}\n"
"\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\n"
")\n"
"\n"
"// Shader allows you to define your own vertex and fragment GLSL shaders. This\n"
"// is a low-level feature, so it\'s very easy to mess up.\n"
"//  \n"
"// In tophat, instead of a main function, shaders provide th_vertex and\n"
"// th_fragment. The signature of th_vertex is:\n"
"// \n"
"// ```\n"
"// vec2 th_vertex(vec2 vert);\n"
"// ```\n"
"// \n"
"// where vert is the position of the vertex taken from the vertex buffer.\n"
"// The output is the vertex shader output.\n"
"//  \n"
"// As for fragment shaders, there are two types of them. One for canvas\n"
"// and one for images. In canvas shaders, the fragment function is very simple:\n"
"// \n"
"// ```\n"
"// vec4 th_fragment(vec4 color);\n"
"// ```\n"
"//  \n"
"// Image fragment function looks like this:\n"
"//  \n"
"// ```\n"
"// vec4 th_fragment(sampler2D tex, vec2 coord);\n"
"// ```\n"
"//  \n"
"// where tex is the texture and coord are the texture coordinates. Be aware to\n"
"// swap the output of the `texture2D` function. Example:\n"
"// \n"
"// ```\n"
"// texture2D(tex, coord).abgr\n"
"// ```\n"
"type Shader* = struct {\n"
"\thandle: int\n"
"}\n"
"\n"
"const (\n"
"\tdefaultImageShader* = Shader{1}\n"
"\tdefaultCanvasShader* = Shader{2}\n"
")\n"
"\n"
"// Represents a GLSL uniform.\n"
"type Uniform* = struct {\n"
"\ts: Shader\n"
"\tl: uint\n"
"}\n"
"\n"
"fn ccompilecanvasshader(vertex, fragment: str): int\n"
"\n"
"// Compiles a canvas shader from source. If there is a compilation error, it\n"
"// will print something to the console.\n"
"fn mkCanvas*(vertex, fragment: str): Shader {\n"
"\treturn Shader{ccompilecanvasshader(vertex, fragment)}\n"
"}\n"
"\n"
"fn ccompileimageshader(vertex, fragment: str): int\n"
"\n"
"// Compiles an image shader from source. If there is a compilation error, it\n"
"// will print something to the console.\n"
"fn mkImage*(vertex, fragment: str): Shader {\n"
"\treturn Shader{ccompileimageshader(vertex, fragment)}\n"
"}\n"
"\n"
"fn cpickcanvasshader(handle: int)\n"
"\n"
"// Picks the shader to be used for canvas drawing. Flushes the canvas batch.\n"
"fn (s: ^Shader) pickForCanvas*() {\n"
"\tcpickcanvasshader(s.handle)\n"
"}\n"
"\n"
"fn cpickimageshader(handle: int)\n"
"\n"
"// Picks the shader to be used for image drawing. Flushes the image batch.\n"
"fn (s: ^Shader) pickForImage*() {\n"
"\tcpickimageshader(s.handle)\n"
"}\n"
"\n"
"fn cgetuniformlocation(handle: int, name: str): uint\n"
"\n"
"// Retunrs a uniform by name.\n"
"fn (s: ^Shader) getUniformLocation*(name: str): Uniform {\n"
"\treturn Uniform{s^, cgetuniformlocation(s.handle, name)}\n"
"}\n"
"\n"
"fn csetuniformint(shandle, uhandle: uint, value: int)\n"
"\n"
"// Sets a uniform to an int value. Flushes both batches.\n"
"fn (u: ^Uniform) setInt*(value: int) {\n"
"\tcsetuniformint(u.s.handle, u.l, value)\n"
"}\n"
"\n"
"fn csetuniformvf2(shandle, uhandle: uint, value: th.Vf2)\n"
"\n"
"// Sets a uniform to a vf2. Flushes both batches.\n"
"fn (u: ^Uniform) setVf2*(value: th.Vf2) {\n"
"\tcsetuniformvf2(u.s.handle, u.l, value)\n"
"}\n"
"",
"// Color operations. Operate on RGBA uint32 values.\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
")\n"
"\n"
"fn umth_hsv2rgb_uint32(h, s, v, a: th.fu): uint32\n"
"\n"
"// Now this is hard to decide, but in my opinion executing a C function,\n"
"//   for the current Umka VM would be much better than implementing it in umka itself.\n"
"// It\'s somewhat less trivial than most other operations like alpha.\n"
"fn umth_rgb_uint32(r, g, b, a: th.fu): uint32\n"
"\n"
"// Converts HSV values into RGBA uint32 color.\n"
"// NOTE: Hue is between 0 and 1\n"
"fn hsv*(h, s, v: th.fu, a: th.fu = 1.0): uint32 {\n"
"\treturn umth_hsv2rgb_uint32(h, s, v, a);\n"
"}\n"
"\n"
"// Sets alpha of the color c to a value in to.\n"
"fn alpha*(c: uint32, to: th.fu): uint32 {\n"
"\treturn (c & 0xFFFFFF00) | (trunc(to * 255) & 0xFF)\n"
"}\n"
"\n"
"// Constructs RGBA uint32 from RGBA of reals.\n"
"fn rgb*(r, g, b: th.fu, a: th.fu = 1.0): uint32 {\n"
"\treturn umth_rgb_uint32(r, g, b, a)\n"
"}\n"
"\n"
"",
"// Builtin collision functions. The ic argument stores the collision position.\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"rect.um\"\n"
")\n"
"\n"
"fn ccolllinetoline(b1, e1, b2, e2, ic: ^th.Vf2): bool\n"
"// Checks for a collision between 2 lines specified by their end points.\n"
"fn lineToLine*(b1, e1, b2, e2: th.Vf2, ic: ^th.Vf2): bool {\n"
"\treturn ccolllinetoline(&b1, &e1, &b2, &e2, ic)\n"
"}\n"
"\n"
"fn ccollpointtoquad(p: ^th.Vf2, q: ^th.Quad, ic: ^th.Vf2): bool\n"
"// Checks for a collision between a vf2 and a quad.\n"
"fn vf2ToQuad*(p: th.Vf2, q: th.Quad, ic: ^th.Vf2): bool {\n"
"\treturn ccollpointtoquad(&p, &q, ic)\n"
"}\n"
"\n"
"fn ccolllinetoquad(b, e: ^th.Vf2, q: ^th.Quad, ic: ^th.Vf2): bool\n"
"// Check for a collision between a line and quad edges.\n"
"fn lineToQuad*(b, e: th.Vf2, q: th.Quad, ic: ^th.Vf2): bool {\n"
"\treturn ccolllinetoquad(&b, &e, &q, ic)\n"
"}\n"
"\n"
"fn ccollquadtoquad(q1, q2: ^th.Quad, ic: ^th.Vf2): bool\n"
"// Check for a collision between two quads.\n"
"fn quadToQuad*(q1, q2: th.Quad, ic: ^th.Vf2): bool {\n"
"\treturn ccollquadtoquad(&q1, &q2, ic)\n"
"}\n"
"\n"
"",
"/**\n"
" * TOML parser and deserializer. Can be used outside of tophat.\n"
" * \n"
" * NUL (\\0) is the EOF character.\n"
" *\n"
" * It CAN\'T handle dates and times yet.\n"
" *\n"
" * Identifier tokens and strings tokens are the same\n"
" * \n"
" * Identifier tokens are not handled in nextToken/nextTokenKind because\n"
" * TOML allows identifiers to start with numbers, so you\'ll have to know when you wanna retrieve it explicitly.\n"
" */\n"
"\n"
"type (\n"
"\tAccessor = []str\n"
"\n"
"\tFileLoc* = struct {\n"
"\t\tline: int\n"
"\t\tcolumn: int\n"
"\t\toffset: int\n"
"\t}\n"
"\t\n"
"\tError* = struct {\n"
"\t\tlocation: FileLoc\n"
"\t\tcode: int\n"
"\t}\t\n"
"\n"
"\tParser = struct {\n"
"\t\tlocation: FileLoc\n"
"\t\tsourceLen: uint\n"
"\t\tsource: str\n"
"\n"
"\t\tarrays: map[str]interface{}\n"
"\t\tsection: map[str]interface{}\n"
"\n"
"\t\terrors: []Error\n"
"\t\tdata: map[str]interface{}\n"
"\t}\n"
"\n"
"\tToken = struct {\n"
"\t\tkind: int\n"
"\t\tvalue: str\n"
"\t\tlocation: FileLoc\n"
"\t}\n"
"\n"
"\tTomlResult* = struct {\n"
"\t\terrors: []Error\n"
"\t\tdata: map[str]interface{}\n"
"\t}\n"
")\n"
"\n"
"\n"
"\n"
"fn errorAtToken(token: Token, code: int): Error {\n"
"\treturn Error{location: token.location, code: code}\n"
"}\n"
"\n"
"fn errorAtParser(parser: ^Parser, code: int): Error {\n"
"\treturn Error{location: parser.location, code: code}\n"
"}\n"
"\n"
"fn errorAtLocation(location: FileLoc, code: int): Error {\n"
"\treturn Error{location: location, code: code}\n"
"}\n"
"\n"
"const (\n"
"\ttokInvalid = 0\n"
"\ttokEof = 1\n"
"\ttokSemi = 2\n"
"\ttokAssign = 3\n"
"\ttokString = 4\n"
"\ttokDot = 5\n"
"\ttokLBrack = 6 // [\n"
"\ttokRBrack = 7 // ]\n"
"\ttokListOpen = 8 // [[ \n"
"\ttokListClose = 9 // ]]\n"
"\ttokMapOpen = 10\n"
"\ttokMapClose = 11\n"
"\ttokDelim = 12\n"
"\n"
"\terrUnknown* = 0\n"
"\terrUnclosedString* = 1\n"
"\terrUnexpectedToken* = 2\n"
"\terrUnexpectedCharacter* = 3\n"
"\terrExpectedKey* = 4\n"
"\terrFieldReassigned* = 5\n"
"\terrExpectedNewLine* = 6\n"
"\terrExpectedDigit* = 7\n"
"\terrCount* = 8\n"
")\n"
"\n"
"fn updateAccessor(accessor: Accessor, tree: map[str]interface{}, value: interface{}): bool {\n"
"\tfor i, key in accessor {\n"
"\t\tif i == len(accessor)-1 {\n"
"\t\t\ttree[key] = value\n"
"\t\t} else {\n"
"\t\t\tif !validkey(tree, key) {\n"
"\t\t\t\ttree[key] = map[str]interface{}{}\n"
"\t\t\t\ttree = map[str]interface{}(tree[key])\n"
"\t\t\t} else if leaf := ^map[str]interface{}(tree[key]); leaf != null {\n"
"\t\t\t\ttree = leaf^\n"
"\t\t\t} else {\n"
"\t\t\t\treturn false\n"
"\t\t\t}\n"
"\t\t}\n"
"\t}\n"
"\n"
"\treturn true\n"
"}\n"
"\n"
"fn setAccessor(accessor: Accessor, tree: map[str]interface{}, value: interface{}): bool {\n"
"\tprintf(\"%s\\n\", repr(tree))\n"
"\tfor i, key in accessor {\n"
"\t\tif i == len(accessor)-1 {\n"
"\t\t\tif !validkey(tree, key) {\n"
"\t\t\t\ttree[key] = value\n"
"\t\t\t} else {\n"
"\t\t\t\treturn false\n"
"\t\t\t}\n"
"\t\t} else {\n"
"\t\t\tif !validkey(tree, key) {\n"
"\t\t\t\ttree[key] = map[str]interface{}{}\n"
"\t\t\t\ttree = map[str]interface{}(tree[key])\n"
"\t\t\t} else if leaf := ^map[str]interface{}(tree[key]); leaf != null {\n"
"\t\t\t\ttree = leaf^\n"
"\t\t\t} else {\n"
"\t\t\t\treturn false\n"
"\t\t\t}\n"
"\t\t}\n"
"\t}\n"
"\n"
"\treturn true\n"
"}\n"
"\n"
"fn getAccessor(accessor: Accessor, tree: map[str]interface{}): interface{} {\n"
"\tfor i, key in accessor {\n"
"\t\tif i == len(accessor)-1 {\n"
"\t\t\tif validkey(tree, key) {\n"
"\t\t\t\treturn tree[key]\n"
"\t\t\t} else {\n"
"\t\t\t\treturn null\n"
"\t\t\t}\n"
"\t\t} else {\n"
"\t\t\tif leaf := ^map[str]interface{}(tree[key]); leaf != null {\n"
"\t\t\t\ttree = leaf^\n"
"\t\t\t} else {\n"
"\t\t\t\treturn null\n"
"\t\t\t}\n"
"\t\t}\n"
"\t}\n"
"\n"
"\treturn null\n"
"}\n"
"\n"
"fn formatError*(error: ^Error, source: str): str {\n"
"\tconst errCodeStr = [errCount]str{\n"
"\t\t\"Unknown error\",\n"
"\t\t\"Unclosed string\",\n"
"\t\t\"Unexpected token\",\n"
"\t\t\"Unexpected character\",\n"
"\t\t\"Invalid token for key\",\n"
"\t\t\"Field reassigned\", \n"
"\t\t\"Expected new line\",\n"
"\t\t\"Expected digit\"}\n"
"\n"
"\treturn sprintf(\"error(%d:%d): %s\", error.location.line+1, error.location.column+1, errCodeStr[error.code])\t\n"
"}\n"
"\n"
"fn isDecimal(c: char): bool {\n"
"\treturn (c >= \'0\' && c <= \'9\')\n"
"}\n"
"\n"
"// [ \\t\\r\\n]\n"
"fn isSkip(c: char): bool {\n"
"\treturn c == \' \' || c == \'\\t\' || c == \'\\r\'\n"
"}\n"
"\n"
"// [A-Za-z0-9_-]\n"
"fn isIdent(c: char): bool {\n"
"\treturn (c >= \'a\' && c <= \'z\') || (c >= \'A\' && c <= \'Z\') || (c >= \'0\' && c <= \'9\') || (c == \'_\') || (c == \'-\')\n"
"}\n"
"\n"
"fn isNumStart(c: char): bool {\n"
"\treturn (c == \'.\') || (c == \'+\') || (c == \'-\') || (c >= \'0\' && c <= \'9\')\n"
"}\n"
"\n"
"// FIXME: this function will choke on invalid input\n"
"fn escapeStr(string: str): str {\n"
"\tpos := 0\n"
"\tpos += 1 // skip \"\n"
"\tresult := \"\"\n"
"\n"
"\tfor pos < len(string) && string[pos] != \"\\\"\" {\n"
"\t\tif string[pos] == \'\\\\\' {\n"
"\t\t\tpos++\n"
"\t\t\tif pos < len(string) {\n"
"\t\t\t\tif string[pos] == \'n\' {\n"
"\t\t\t\t\tresult += \'\\n\'\n"
"\t\t\t\t} else {\n"
"\t\t\t\t\tresult += string[pos]\n"
"\t\t\t\t}\n"
"\t\t\t\tpos++\n"
"\t\t\t}\n"
"\t\t} else {\n"
"\t\t\tresult += string[pos]\n"
"\t\t\tpos++\n"
"\t\t}\n"
"\t}\n"
"\n"
"\treturn result\n"
"}\n"
"\n"
"fn (p: ^Parser) emitError(error: Error) {\n"
"\tp.errors = append(p.errors, error)\n"
"}\n"
"\n"
"fn (p: ^Parser) next() {\n"
"\tif p.location.offset < p.sourceLen {\n"
"\t\tif p.source[p.location.offset] == \'\\n\' {\n"
"\t\t\tp.location.line += 1\n"
"\t\t\tp.location.column = 0\n"
"\t\t} else {\n"
"\t\t\tp.location.column += 1\n"
"\t\t}\n"
"\t\tp.location.offset += 1\n"
"\t}\n"
"}\n"
"\n"
"fn (p: ^Parser) get(): char {\n"
"\tif p.location.offset >= p.sourceLen {\n"
"\t\treturn \'\\0\'\n"
"\t}\n"
"\treturn p.source[p.location.offset]\n"
"}\n"
"\n"
"\n"
"fn (p: ^Parser) skipSpaces(): bool {\n"
"\tfoundSome := isSkip(p.get())\n"
"\n"
"\tfor isSkip(p.get()) {\n"
"\t\tp.next()\n"
"\t}\n"
"\n"
"\treturn foundSome\n"
"}\n"
"\n"
"fn (p: ^Parser) skipComments(): bool {\n"
"\tif p.get() == \'#\' {\n"
"\t\tfor p.get() != \'\\0\' && p.get() != \'\\n\' {\n"
"\t\t\tp.next()\n"
"\t\t}\n"
"\t\treturn true\n"
"\t}\n"
"\treturn false\n"
"}\n"
"\n"
"fn (p: ^Parser) skipBlank() {\n"
"\tfor p.skipSpaces() || p.skipComments() {}\n"
"}\n"
"\n"
"fn (p: ^Parser) expectToken(token: Token, toBeKind: int) {\n"
"\tif token.kind != toBeKind {\n"
"\t\tp.emitError(errorAtToken(token, errUnexpectedToken))\n"
"\t}\n"
"}\n"
"\n"
"fn (p: ^Parser) nextIdent(): str {\n"
"\n"
"\tif !isIdent(p.get()) {\n"
"\t\treturn \"\"\n"
"\t}\n"
"\n"
"\tvalue := \"\"\n"
"\tfor isIdent(p.get()) {\n"
"\t\tvalue += p.get()\n"
"\t\tp.next()\n"
"\t}\n"
"\n"
"\treturn value\n"
"}\n"
"\n"
"fn (p: ^Parser) nextTokenString(): int {\n"
"\tlocation := p.location\n"
"\n"
"\tp.next() // Skip quote\n"
"\tfor p.get() != \'\\0\' && p.get() != \'\\n\' && p.get() != \'\"\' {\n"
"\t\tif p.get() == \'\\\\\' {\n"
"\t\t\tp.next()\n"
"\t\t}\n"
"\t\tp.next()\n"
"\t}\n"
"\n"
"\t// Unfinished string\n"
"\tif p.get() == \'\\0\' || p.get() == \'\\n\' {\n"
"\t\tp.emitError(errorAtLocation(location, errUnclosedString))\n"
"\t\treturn tokInvalid\n"
"\t}\n"
"\n"
"\tp.next() // Skip quote\n"
"\treturn tokString\n"
"}\n"
"\n"
"fn (p: ^Parser) nextTokenKind(): int {\n"
"\tswitch (p.get()) {\n"
"\t\tcase \'\"\':\n"
"\t\t\treturn p.nextTokenString()\n"
"\t\tcase \'=\': \n"
"\t\t\tp.next() // skip \'=\'\n"
"\t\t\treturn tokAssign\n"
"\t\tcase \'.\': \n"
"\t\t\tp.next() // skip \'.\'\n"
"\t\t\treturn tokDot\n"
"\t\tcase \'[\': \n"
"\t\t\tp.next() // skip \'[\'\n"
"\t\t\tif p.get() == \'[\' {\n"
"\t\t\t\tp.next() // skip \'[\'\n"
"\t\t\t\treturn tokListOpen\n"
"\t\t\t}\n"
"\t\t\treturn tokLBrack\n"
"\t\tcase \']\': \n"
"\t\t\tp.next() // skip \']\'\n"
"\t\t\tif p.get() == \']\' {\n"
"\t\t\t\tp.next() // skip \']\'\n"
"\t\t\t\treturn tokListClose\n"
"\t\t\t}\n"
"\t\t\treturn tokRBrack\n"
"\t\tcase \'{\': \n"
"\t\t\tp.next() // skip \'{\'\n"
"\t\t\treturn tokMapOpen\n"
"\t\tcase \'}\': \n"
"\t\t\tp.next() // skip \'}\'\n"
"\t\t\treturn tokMapClose\n"
"\t\tcase \',\': \n"
"\t\t\tp.next() // skip \'}\'\n"
"\t\t\treturn tokDelim\n"
"\t\tcase \'\\n\': \n"
"\t\t\tp.next() // skip \'\\n\'\n"
"\t\t\treturn tokSemi\n"
"\t\tcase \'\\0\': \n"
"\t\t\treturn tokEof\n"
"\t\tdefault:\n"
"\t\t\t// HACK eh? Toml has a semi context dependent thing where you need to know when to pull a key and when to pull \n"
"\t\t\t//\t  \t\t\ta number, because both numbers and keys can start with digits (and dash)...\n"
"\t\t\t//\t\t\t\t\tI\'ll better figure it out. \n"
"\t\t\tif !isIdent(p.get()) && !isNumStart(p.get()) {\n"
"\t\t\t\tp.emitError(errorAtParser(p, errUnexpectedCharacter))\n"
"\t\t\t}\n"
"\t\t\treturn tokInvalid\n"
"\t}\n"
"\treturn tokInvalid\n"
"}\n"
"\n"
"fn (p: ^Parser) nextKeyIdent(): Token {\n"
"\tp.skipBlank()\n"
"\tlocation := p.location\n"
"\tstart := p.location.offset\n"
"\ttt := tokInvalid\n"
"\n"
"\t// TODO: Maybe have a different nextIdent function which returns ok/fail instead of a string\n"
"\tif p.nextIdent() != \"\" {\n"
"\t\ttt = tokString\n"
"\t} else {\n"
"\t\ttt = p.nextTokenKind()\n"
"\t}\n"
"\n"
"\tend := p.location.offset\n"
"\n"
"\ttoken := Token{kind: tt, value: slice(p.source, start, end), location: location}\n"
"\n"
"\tif tt != tokString {\n"
"\t\tp.emitError(errorAtToken(token, errExpectedKey))\n"
"\t}\n"
"\n"
"\treturn token\n"
"}\n"
"\n"
"fn (p: ^Parser) nextToken(): Token {\n"
"\tp.skipBlank()\n"
"\n"
"\tlocation := p.location\n"
"\tstart := p.location.offset\n"
"\n"
"\ttt := p.nextTokenKind()\n"
"\n"
"\tend  := p.location.offset\n"
"\n"
"\treturn Token{kind: tt, value: slice(p.source, start, end), location: location}\n"
"}\n"
"\n"
"fn (p: ^Parser) peekToken(): Token {\n"
"\ttempLoc := p.location\n"
"\n"
"\ttoken := p.nextToken()\n"
"\n"
"\tp.location = tempLoc\n"
"\n"
"\treturn token\n"
"}\n"
"\n"
"// Runs escape sequences, if it\'s a quote string\n"
"fn escapeStrToken(token: Token): str {\n"
"\tif token.kind == tokString && token.value[0] == \'\"\' {\n"
"\t\treturn escapeStr(token.value)\n"
"\t}\n"
"\treturn token.value\n"
"}\n"
"\n"
"fn (p: ^Parser) parseAccessor(): Accessor {\n"
"\taccessor := Accessor{escapeStrToken(p.nextKeyIdent())}\n"
"\n"
"\tfor p.peekToken().kind == tokDot {\n"
"\t\tp.nextToken() // Skip dot\n"
"\t\taccessor = append(accessor, escapeStrToken(p.nextKeyIdent()))\n"
"\t}\n"
"\n"
"\treturn accessor\n"
"}\n"
"\n"
"fn (p: ^Parser) setAccessor(location: FileLoc, accessor: Accessor, tree: map[str]interface{}, value: interface{}) {\n"
"\tif !setAccessor(accessor, tree, value) {\n"
"\t\tp.emitError(errorAtLocation(location, errFieldReassigned))\n"
"\t}\n"
"}\n"
"\n"
"fn (p: ^Parser) updateAccessor(location: FileLoc, accessor: Accessor, tree: map[str]interface{}, value: interface{}) {\n"
"\tif !updateAccessor(accessor, tree, value) {\n"
"\t\tp.emitError(errorAtLocation(location, errFieldReassigned))\n"
"\t}\n"
"}\n"
"\n"
"fn (p: ^Parser) parseDigitSeq(): (int, int) {\n"
"\tnumber := 0\n"
"\tdivisor := 1\n"
"\n"
"\tif !isDecimal(p.get()) {\n"
"\t\tp.emitError(errorAtParser(p, errExpectedDigit))\n"
"\t\treturn 0, 1\n"
"\t}\n"
"\n"
"\tfor isDecimal(p.get()) {\n"
"\t\tnumber = number*10 + (int(p.get())-int(\'0\'))\n"
"\t\tdivisor *= 10\n"
"\t\tp.next()\n"
"\n"
"\t\tif p.get() == \'_\' {\n"
"\t\t\tp.next()\n"
"\t\t\tif !isDecimal(p.get()) {\n"
"\t\t\t\tp.emitError(errorAtParser(p, errExpectedDigit))\n"
"\t\t\t\treturn number, divisor\n"
"\t\t\t}\n"
"\t\t}\n"
"\t}\n"
"\n"
"\treturn number, divisor\n"
"}\n"
"\n"
"fn (p: ^Parser) parseNumber(): interface{} {\n"
"\tsign := 1\n"
"\n"
"\tif p.get() == \'-\' {\n"
"\t\tp.next()\n"
"\t\tsign = -1\n"
"\t} else if p.get() == \'+\' {\n"
"\t\tp.next()\n"
"\t\tsign = 1\n"
"\t}\n"
"\n"
"\tnumberInt, _ := p.parseDigitSeq()\n"
"\t\n"
"\tif p.get() == \'.\' {\n"
"\t\tp.next()\n"
"\t\tnumberFloat, divisor := p.parseDigitSeq()\n"
"\t\treturn (real(numberFloat)/divisor+numberInt)*sign\n"
"\t}\n"
"\n"
"\treturn numberInt*sign\n"
"}\n"
"\n"
"fn (p: ^Parser) isntToken(kind: int): bool {\n"
"\ttok := p.peekToken()\n"
"\treturn tok.kind != kind && tok.kind != tokEof\n"
"}\n"
"\n"
"type NeedSkip = struct{}\n"
"\n"
"fn (p: ^Parser) parseKeyValue(into: map[str]interface{})\n"
"fn (p: ^Parser) parseMap(): map[str]interface{} {\n"
"\tresult := map[str]interface{}{}\n"
"\n"
"\tp.expectToken(p.nextToken(), tokMapOpen)\n"
"\tfor p.isntToken(tokMapClose) {\n"
"\t\tp.parseKeyValue(result)\n"
"\n"
"\t\tif p.isntToken(tokMapClose) {\n"
"\t\t\tp.expectToken(p.nextToken(), tokDelim)\n"
"\t\t}\n"
"\t}\n"
"\n"
"\tp.expectToken(p.nextToken(), tokMapClose)\n"
"\treturn result\n"
"}\n"
"\n"
"fn (p: ^Parser) parseValue(): interface{}\n"
"fn (p: ^Parser) parseArray(): []interface{} {\n"
"\tresult := []interface{}{}\n"
"\n"
"\tp.expectToken(p.nextToken(), tokLBrack)\n"
"\tfor p.isntToken(tokRBrack) {\n"
"\t\t// FIXME: Could there be a better way to do this? Sigh..\n"
"\t\tfor p.peekToken().kind == tokSemi {\n"
"\t\t\tp.nextToken()\n"
"\t\t}\n"
"\n"
"\t\tresult = append(result, p.parseValue())\n"
"\n"
"\t\tfor p.peekToken().kind == tokSemi {\n"
"\t\t\tp.nextToken()\n"
"\t\t}\n"
"\n"
"\t\tif p.isntToken(tokRBrack) {\n"
"\t\t\tp.expectToken(p.nextToken(), tokDelim)\n"
"\t\t}\n"
"\t}\n"
"\n"
"\tp.expectToken(p.nextToken(), tokRBrack)\n"
"\treturn result\n"
"}\n"
"\n"
"fn (p: ^Parser) parseValue(): interface{} {\n"
"\tp.skipBlank()\n"
"\n"
"\tif p.peekToken().kind == tokLBrack {\n"
"\t\treturn p.parseArray()\n"
"\t} else if p.peekToken().kind == tokMapOpen {\n"
"\t\treturn p.parseMap()\n"
"\t} else if p.get() == \'\"\' {\n"
"\t\tvalue := p.nextToken()\n"
"\t\tp.expectToken(value, tokString)\n"
"\t\treturn escapeStrToken(value)\n"
"\t} else if isNumStart(p.get()) {\n"
"\t\treturn p.parseNumber()\n"
"\t} else if ident := p.nextIdent(); ident == \"true\" || ident == \"false\" {\n"
"\t\treturn ident == \"true\"\n"
"\t} else {\n"
"\t\tp.emitError(errorAtParser(p, errUnexpectedCharacter))\n"
"\t}\n"
"\n"
"\treturn null\n"
"}\n"
"\n"
"fn (p: ^Parser) parseKeyValue(into: map[str]interface{}) {\n"
"\tlocation := p.location\n"
"\taccessor := p.parseAccessor()\n"
"\n"
"\tp.expectToken(p.nextToken(), tokAssign)\n"
"\n"
"\tvalue := p.parseValue()\n"
"\n"
"\tprintf(\"Set `%s` = `%s`\\n\", repr(accessor), repr(value))\n"
"\t\n"
"\tp.setAccessor(location, accessor, into, value)\n"
"}\n"
"\n"
"fn (p: ^Parser) parseSection() {\n"
"\tp.expectToken(p.nextToken(), tokLBrack)\n"
"\n"
"\tlocation := p.location\n"
"\tp.section = map[str]interface{}{}\n"
"\tp.setAccessor(location, p.parseAccessor(), p.data, p.section)\n"
"\tp.expectToken(p.nextToken(), tokRBrack)\n"
"}\n"
"\n"
"fn (p: ^Parser) parseSectionArray() {\n"
"\tp.expectToken(p.nextToken(), tokListOpen)\n"
"\tlocation := p.location\n"
"\taccessor := p.parseAccessor()\n"
"\n"
"\tp.section = map[str]interface{}{}\n"
"\n"
"\tprintf(\"%s\\n\", repr(getAccessor(accessor, p.arrays)))\n"
"\tif arr := ^[]interface{}(getAccessor(accessor, p.arrays)); arr != null {\n"
"\t\tarr ^= append(arr^, p.section)\n"
"\t\tp.updateAccessor(location, accessor, p.data, arr^)\n"
"\t} else {\n"
"\t\tarray := new([]interface{})\n"
"\t\tarray ^= []interface{}{p.section}\n"
"\n"
"\t\tif !setAccessor(accessor, p.arrays, array) {\n"
"\t\t\tp.emitError(errorAtLocation(location, errFieldReassigned))\n"
"\t\t}\n"
"\n"
"\t\tp.setAccessor(location, accessor, p.data, array^)\n"
"\t}\n"
"\n"
"\tp.expectToken(p.nextToken(), tokListClose)\n"
"}\n"
"\n"
"fn (p: ^Parser) expectSemi() {\n"
"\ttoken := p.nextToken()\n"
"\tif !(token.kind == tokSemi || token.kind == tokEof) {\n"
"\t\tp.emitError(errorAtToken(token, errExpectedNewLine))\n"
"\t}\n"
"}\n"
"\n"
"fn (p: ^Parser) parseToplevel() {\n"
"\tswitch p.peekToken().kind {\n"
"\t\t// NOTE: Skip until the end of source, since peek doesn\'t move to the end of file while we skip spaces\n"
"\t\tcase tokEof: p.nextToken() \n"
"\t\tcase tokSemi: p.nextToken()\n"
"\n"
"\t\tcase tokListOpen: \n"
"\t\t\tp.parseSectionArray()\n"
"\t\t\tp.expectSemi()\n"
"\t\tcase tokLBrack: \n"
"\t\t\tp.parseSection()\n"
"\t\t\tp.expectSemi()\n"
"\t\tdefault:\n"
"\t\t\tp.parseKeyValue(p.section) \n"
"\t\t\tp.expectSemi()\n"
"\t}\n"
"}\n"
"\n"
"fn parse*(source: str): TomlResult {\n"
"\tp := Parser{source: source, sourceLen: len(source), errors: []Error{}, arrays: map[str]interface{}{}, data: map[str]interface{}{}}\n"
"\tp.section = p.data\n"
"\n"
"\tfor len(p.errors) == 0 && p.peekToken().kind != tokEof {\n"
"\t\tp.parseToplevel()\n"
"\t}\n"
"\n"
"\treturn TomlResult{p.errors, p.data}\n"
"}\n"
"\n"
"fn (r: ^TomlResult) getError*(): ^Error {\n"
"\tif len(r.errors) > 0 {\n"
"\t\treturn &r.errors[0]\n"
"\t}\n"
"\treturn null\n"
"}\n"
"",
"import(\"image.um\"; \"th.um\")\n"
"var (\n"
"\ttest*: image.Image\n"
")\n"
"fn init*() {\n"
"\ttest = image.mk([]uint32{ 0xd0350aff, 0xd0350aff, 0xd0350aff, 0xd0350aff, 0xd0350aff, 0xd0350aff, 0xd0350aff, 0xd0350aff, 0xd0350aff, 0xd0350aff, 0xd0350aff, 0xd0350aff, 0xd0350aff, 0xd0350aff, 0xd0350aff, 0xd0350aff, 0xd0350aff, 0xd0350aff, 0xd0350aff, 0xd0350aff, 0xd0350aff, 0xd0350aff, 0xd0350aff, 0xd0350aff, 0xf80c3fff, 0xf80c3fff, 0xf80cefff, 0xf80cefff, 0x200ad0ff, 0x200ad0ff, 0xad0d0ff, 0xad0d0ff, 0xad03dff, 0xad03dff, 0xd0c00aff, 0xd0c00aff, 0xf80c3fff, 0xf80c3fff, 0xf80cefff, 0xf80cefff, 0x200ad0ff, 0x200ad0ff, 0xad0d0ff, 0xad0d0ff, 0xad03dff, 0xad03dff, 0xd0c00aff, 0xd0c00aff, 0xf80c3fff, 0xf80c3fff, 0xf80cefff, 0xf80cefff, 0x200ad0ff, 0x200ad0ff, 0xad0d0ff, 0xad0d0ff, 0xad03dff, 0xad03dff, 0xd0c00aff, 0xd0c00aff, 0xf80c3fff, 0xf80c3fff, 0xf80cefff, 0xf80cefff, 0x200ad0ff, 0x200ad0ff, 0xad0d0ff, 0xad0d0ff, 0xad03dff, 0xad03dff, 0xd0c00aff, 0xd0c00aff, 0xf80c3fff, 0xf80c3fff, 0xf80cefff, 0xf80cefff, 0x200ad0ff, 0x200ad0ff, 0xad0d0ff, 0xad0d0ff, 0xad03dff, 0xad03dff, 0xd0c00aff, 0xd0c00aff, 0xf80c3fff, 0xf80c3fff, 0xf80cefff, 0xf80cefff, 0x200ad0ff, 0x200ad0ff, 0xad0d0ff, 0xad0d0ff, 0xad03dff, 0xad03dff, 0xd0c00aff, 0xd0c00aff, 0xf80c3fff, 0xf80c3fff, 0xf80cefff, 0xf80cefff, 0x200ad0ff, 0x200ad0ff, 0xad0d0ff, 0xad0d0ff, 0xad03dff, 0xad03dff, 0xd0c00aff, 0xd0c00aff, 0xf80c3fff, 0xf80c3fff, 0xf80cefff, 0xf80cefff, 0x200ad0ff, 0x200ad0ff, 0xad0d0ff, 0xad0d0ff, 0xad03dff, 0xad03dff, 0xd0c00aff, 0xd0c00aff, 0xf80c3fff, 0xf80c3fff, 0xf80cefff, 0xf80cefff, 0x200ad0ff, 0x200ad0ff, 0xad0d0ff, 0xad0d0ff, 0xad03dff, 0xad03dff, 0xd0c00aff, 0xd0c00aff, 0xf80c3fff, 0xf80c3fff, 0xf80cefff, 0xf80cefff, 0x200ad0ff, 0x200ad0ff, 0xad0d0ff, 0xad0d0ff, 0xad03dff, 0xad03dff, 0xd0c00aff, 0xd0c00aff }, th.Vf2{ 12, 12 })\n"
"}\n"
"",
};
const char *th_em_modulenames[] = { "anim.um", "audio.um", "csv.um", "ent.um", "image.um", "input.um", "misc.um", "canvas.um", "ray.um", "rect.um", "tilemap.um", "window.um", "ui.um", "std/std.um", "particles.um", "light.um", "lerp.um", "utf8.um", "font.um", "th.um", "signal.um", "atlas.um", "ui/label.um", "ui/grid.um", "ui/imagebox.um", "shader.um", "color.um", "coll.um", "toml.um", "images.um",  };
int th_em_modulenames_count = 30;
const char *th_em_misc[] = {
"BSD 3-Clause License\n"
"\n"
"Copyright (c) 2021, Marek Maskarinec\n"
"All rights reserved.\n"
"\n"
"Redistribution and use in source and binary forms, with or without\n"
"modification, are permitted provided that the following conditions are met:\n"
"\n"
"1. Redistributions of source code must retain the above copyright notice, this\n"
"   list of conditions and the following disclaimer.\n"
"\n"
"2. Redistributions in binary form must reproduce the above copyright notice,\n"
"   this list of conditions and the following disclaimer in the documentation\n"
"   and/or other materials provided with the distribution.\n"
"\n"
"3. Neither the name of the copyright holder nor the names of its\n"
"   contributors may be used to endorse or promote products derived from\n"
"   this software without specific prior written permission.\n"
"\n"
"THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n"
"AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n"
"IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n"
"DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n"
"FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n"
"DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n"
"SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n"
"CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n"
"OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n"
"OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
"",
"v0.7\n"
"",
};
