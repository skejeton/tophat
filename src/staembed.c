const char *th_em_modulesrc[] = {
"// Module for frame based image animation.\n"
"// TODO: Rework this module to use atlases.\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"image.um\"\n"
"\t\"rect.um\"\n"
")\n"
"\n"
"// Anim is able to animate an array of images. As opposed to ent.Ent.animate,\n"
"// it starts from the first frame.\n"
"type Anim* = struct {\n"
"\tanim: []image.Image\n"
"\trot: th.fu\n"
"\tscale: th.fu\n"
"\tfps: th.uu\n"
"\tlooping: bool\n"
"\n"
"\tpos: th.Vf2\n"
"\n"
"\tzeroTime: int\n"
"\n"
"\tframe: int\n"
"}\n"
"\n"
"// Anim\'s constructor.\n"
"fn mk*(pos: th.Vf2, anm: []image.Image, fps: th.uu): Anim {\n"
"\ta := Anim{}\n"
"\n"
"\ta.anim = append(anm, anm[len(anm)-1])\n"
"\n"
"\ta.fps = fps\n"
"\ta.scale = 1\n"
"\ta.rot = 0\n"
"\n"
"\ta.pos = pos\n"
"\n"
"\ta.looping = false\n"
"\n"
"\treturn a\n"
"}\n"
"\n"
"// Starts animation with start_time of t.\n"
"fn (a: ^Anim) start*(t: int) {\n"
"\ta.zeroTime = t\n"
"}\n"
"\n"
"// This draws the animation. Returns true, if the animation ended.\n"
"fn (a: ^Anim) handle*(t: uint, cam: rect.Rect): bool {\n"
"\ta.frame = (round(real(t-a.zeroTime)/round((1000.0/a.fps))) % len(a.anim))\n"
"\n"
"\ta.anim[a.frame].draw(\n"
"\t\tth.Transform{\n"
"\t\t\tth.Vf2{round(a.pos.x) - cam.x + cam.w/2, round(a.pos.y) - cam.y + cam.h/2},\n"
"\t\t\tth.Vf2{a.scale, a.scale}, th.Vf2{}, a.rot})\n"
"\n"
"\tif a.frame == len(a.anim) - 1 {\n"
"\t\tif a.looping {\n"
"\t\t\ta.zeroTime = t\n"
"\t\t} else {\n"
"\t\t\treturn true\n"
"\t\t}\n"
"\t}\n"
"\n"
"\treturn false\n"
"}\n"
"",
"// Module for audio loading and playback.\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
")\n"
"\n"
"// A structure used to create playbacks.\n"
"type Sound* = struct {\n"
"\tlooping: bool\n"
"\tvolume: th.fu\n"
"\tpath: str\n"
"}\n"
"\n"
"// Playback is a currently played instance of a sound.\n"
"// The properties are set to the value the sound has.\n"
"// sound.play returns a pointer. Be sure to keep it if you want to\n"
"// change the sound while its playing.\n"
"type Playback* = struct{\n"
"\tdecoder: ^struct{}\n"
"\t// Indicates if the sound is playing.\n"
"\tplaying: bool\n"
"\t// If set to true, playback will be paused.\n"
"\tpaused: bool\n"
"\t// If true, playback will keep on playing again after it ends.\n"
"\tlooping: bool\n"
"\t// Multiplier of the volume.\n"
"\tvolume: th.fu\n"
"\t// Sets the current PCM frame. Write only.\n"
"\tframe: int\n"
"}\n"
"\n"
"fn csoundplay(s: ^Sound): ^Playback\n"
"\n"
"// Loads sound at a path.\n"
"fn load*(path: str): Sound {\n"
"\treturn Sound{\n"
"\t\tlooping: false,\n"
"\t\tvolume: 1,\n"
"\t\tpath: path }\n"
"}\n"
"\n"
"// Plays the sound.\n"
"fn (s: ^Sound) play*(): ^Playback {\n"
"\treturn csoundplay(s)\n"
"}\n"
"",
"\n"
"fn gettocomma(s: int, inp: str, le: ^int): str {\n"
"\tout := \"\"\n"
"\ti := s\n"
"\tfor _ := 0; i < len(inp) && inp[i] != \',\' && inp[i] != \'\\n\'; i++ {\n"
"\t\tout += inp[i]\n"
"\t}\n"
"\tle^ = i - 1\n"
"\treturn out\n"
"}\n"
"\n"
"// Parses input into a 2d string array.\n"
"fn parse*(inp: str): [][]str {\n"
"\tout := [][]str{}\n"
"\tvar r, c: int\n"
"\tout = append(out, []str{gettocomma(0, inp, &c)})\n"
"\tc = 1\n"
"\tfor i:=0; i < len(inp); i++ {\n"
"\t\tif inp[i] == \'\\n\' {\n"
"\t\t\tr++\n"
"\t\t\tc = 1\n"
"\t\t\tout = append(out, []str{gettocomma(i+1, inp, &i)})\n"
"\t\t} else if inp[i] == \',\' {\n"
"\t\t\tout[r] = append(out[r], gettocomma(i+1, inp, &i))\n"
"\t\t\tc++\n"
"\t\t}\n"
"\t}\n"
"\treturn out\n"
"}\n"
"\n"
"// Converts 2d array to csv string.\n"
"fn encode*(inp: [][]str): str {\n"
"\tout := \"\"\n"
"\tfor i:=0; i < len(inp); i++ {\n"
"\t\tfor j:=0; j < len(inp[i]); j++ {\n"
"\t\t\tout += inp[i][j]\n"
"\t\t\tif j < len(inp[i])-1 { out += \",\" }\n"
"\t\t}\n"
"\t\tout += \"\\n\"\n"
"\t}\n"
"\treturn out\n"
"}\n"
"\n"
"",
"\n"
"import (\n"
"\t\"rect.um\"\n"
"\t\"image.um\"\n"
"\t\"th.um\"\n"
")\n"
"\n"
"// Entity is the main game object. It features drawing and collisions.\n"
"// Every entity has an image used for drawing and a rectangle used\n"
"// for collisions. It also has a transform used for transforming it\'s image\n"
"// and rectangle.\n"
"type Ent* = struct {\n"
"\t// used as a collider, used as backup when invalid image is supplied\n"
"\tr: rect.Rect\n"
"\t// used in drawing\n"
"\ti: image.Image\n"
"\t// used to transform and translate the image and rect\n"
"\tt: th.Transform\n"
"\t// used as a color of the rect and a color filter for the image\n"
"\tc: uint32\n"
"}\n"
"\n"
"// Value returned by get coll. It contains a position where the collision\n"
"// happened and the index of the entity involved in said collision.\n"
"type Coll* = struct {\n"
"\tindex: th.uu\n"
"\tpos: th.Vf2\n"
"}\n"
"\n"
"fn centdraw(e: ^Ent, c: ^rect.Rect)\n"
"\n"
"// Draws the entity onto the screen in relaction to camera c.\n"
"fn (e: ^Ent) draw*(c: rect.Rect) {\n"
"\tcentdraw(e, &c)\n"
"}\n"
"\n"
"fn cgetcoll(coll: ^Coll, collC: ^int, maxCount: th.uu, count: int32, e: ^Ent, s: ^^Ent)\n"
"\n"
"// ent\'s constructor\n"
"fn mk*(img: image.Image = image.Image{}, t: th.Transform = th.Transform{ s: th.Vf2{1, 1} }): Ent {\n"
"\tvar e: Ent\n"
"\te.i = img\n"
"\te.t = t\n"
"\tif img.validate() {\n"
"\t\tdm := img.getDims()\n"
"\t\te.r.w = dm.x\n"
"\t\te.r.h = dm.y\n"
"\t}\n"
"\te.c = th.white\n"
"\n"
"\tif t.s.x == 0 && t.s.y == 0 {\n"
"\t\tt.s = th.Vf2{ 1, 1 }\n"
"\t}\n"
"\n"
"\treturn e\n"
"}\n"
"\n"
"// Checks collisions of e with entities in s. Checks at max maxColl collisions.\n"
"// If s contains e, the collision won\'t be returned.\n"
"fn (e: ^Ent) getColl*(s: []^Ent, maxColls: th.uu): []Coll {\n"
"\tif len(s) == 0 {\n"
"\t\treturn []Coll{}\n"
"\t}\n"
"\n"
"\tif maxColls > len(s) {\n"
"\t\tmaxColls = len(s)\n"
"\t}\n"
"\n"
"\tif maxColls == 0 {\n"
"\t\tmaxColls = 1\n"
"\t}\n"
"\n"
"\tcolls := make([]Coll, maxColls)\n"
"\tcount := 0\n"
"\tcgetcoll(&colls[0], &count, maxColls, len(s), e, &s[0])\n"
"\n"
"\treturn slice(colls, 0, count)\n"
"}\n"
"\n"
"// Animates the entity\'s image with one of the `anim` array. <b>Won\'t</b> begin on\n"
"// the first frame. If you want that, use anim.Anim.\n"
"fn (e: ^Ent) animate*(fps: int, frames: ^[]image.Image, t: int) {\n"
"\te.i = frames^[(round(real(t)/(1000/fps)) % len(frames^))]\n"
"}\n"
"\n"
"fn centysort(e: ^ent.Ent, count: int)\n"
"\n"
"// Performs an y sort on entities.\n"
"fn ysort*(ents: ^[]ent.Ent) {\n"
"\tif len(ents^) > 0 {\n"
"\t\tcentysort(&ents[0], len(ents^))\n"
"\t}\n"
"}\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\n"
")\n"
"\n"
"// Represents a drawable image. It is an opaque structure.\n"
"// Images support a color filter. It is applied by multiplying the color\n"
"// of each pixel with the filter.\n"
"type Image* = struct{ _: ^struct{} }\n"
"\n"
"fn loadimg(ret: ^Image, path: ^char)\n"
"fn flipvimg(i: Image, f: bool)\n"
"fn fliphimg(i: Image, f: bool)\n"
"fn cdrawimage(img: Image, t: ^th.Transform, color: uint32)\n"
"fn imggetdims(dm: ^th.Vf2, i: Image)\n"
"fn imgcrop(img: Image, tl, br: th.Vf2)\n"
"fn imgfromdata(ret: ^Image, data: ^uint32, dm: th.Vf2)\n"
"fn imgcopy(ret: ^Image, data: Image)\n"
"fn imgsetfilter(data: Image, filter: int)\n"
"fn imgdrawonquad(img: Image, color: uint32, q: [4]th.Vf2)\n"
"fn imgupdatedata(img: Image, data: ^uint32, dm: th.Vf2)\n"
"fn imggetdata(img: Image, data: ^uint32)\n"
"\n"
"// Loads an image at path.\n"
"fn load*(path: str): Image {\n"
"\timg := Image{}\n"
"\tloadimg(&img, &path[0])\n"
"\treturn img\n"
"}\n"
"\n"
"// Flips image on it\'s vertical axis.\n"
"fn (i: ^Image) flipv*(flip: bool) {\n"
"\tflipvimg(i^, flip)\n"
"}\n"
"\n"
"// Flips image on it\'s horizontal axis.\n"
"fn (i: ^Image) fliph*(flip: bool) {\n"
"\tfliphimg(i^, flip)\n"
"}\n"
"\n"
"// Draws the image in screen coordinates. It transforms it with t and\n"
"// applies color as a color filter.\n"
"fn (i: ^Image) draw*(t: th.Transform, color: uint32 = th.white) {\n"
"\tcdrawimage(i^, &t, color)\n"
"}\n"
"\n"
"// Draws the image on top of a quad with corners of the image positioned\n"
"// on the verticies of the quad.\n"
"fn (i: ^Image) drawOnQuad*(q: [4]th.Vf2, color: uint32 = th.white) {\n"
"\timgdrawonquad(i^, color, q)\n"
"}\n"
"\n"
"// Returns true, if i\'s handle points to an image.\n"
"fn (i: ^Image) validate*(): bool {\n"
"\treturn i._ != null\n"
"}\n"
"\n"
"// Returns width and heigth.\n"
"fn (i: ^Image) getDims*(): th.Vf2 {\n"
"\tout := th.Vf2{}\n"
"\timggetdims(&out, i^)\n"
"\n"
"\treturn out\n"
"}\n"
"\n"
"// Crops an image. Coordinates are between 0, 0 (top left) and\n"
"// 1, 1 (bottom right)\n"
"fn (i: ^Image) crop*(tl, br: th.Vf2) {\n"
"\timgcrop(i^, tl, br)\n"
"}\n"
"\n"
"// Creates an image from raw data.\n"
"fn mk*(data: []uint32, dm: th.Vf2): Image {\n"
"\timg := Image{}\n"
"\timgfromdata(&img, &data[0], dm)\n"
"\n"
"\treturn img\n"
"}\n"
"\n"
"// Copies image into a new one.\n"
"fn (i: ^Image) copy*(): Image {\n"
"\timg := Image{}\n"
"\timgcopy(&img, i^)\n"
"\t\n"
"\treturn img\n"
"}\n"
"\n"
"// Sets a mag/min filter. 0 is linear, others are nearest.\n"
"// This function will regenerate the texture. This means it shouldn\'t be\n"
"// used in a loop.\n"
"// https://learnopengl.com/img/getting-started/texture_filtering.png\n"
"// left is nearest, right is linear.\n"
"fn (i: ^Image) setfilter*(filter: int) {\n"
"\timgsetfilter(i^, filter)\n"
"}\n"
"\n"
"// Updates the image data. dm are the dimensions of the new image.\n"
"// The new image doesn\'t have to be the same size as the old one.\n"
"fn (i: ^Image) setData*(data: []uint32, dm: th.Vf2) {\n"
"\tif dm.x * dm.y != len(data) {\n"
"\t\terror(\"setData: incorrect dimensions: \" + repr(dm.x * dm.y) + \"!= \" + repr(len(data)))\n"
"\t}\n"
"\n"
"\tif len(data) == 0 {\n"
"\t\terror(\"setData: can\'t set empty image\")\n"
"\t}\n"
"\n"
"\timgupdatedata(i^, &data[0], dm)\n"
"}\n"
"\n"
"// Gets the image data.\n"
"fn (i: ^Image) getData*(): []uint32 {\n"
"\tif i._ == null {\n"
"\t\treturn []uint32{}\n"
"\t}\n"
"\n"
"\tbuf := make([]uint32, trunc(i.getDims().x * i.getDims().y))\n"
"\tif len(buf) == 0 {\n"
"\t\treturn buf\n"
"\t}\n"
"\n"
"\timggetdata(i^, &buf[0])\n"
"\n"
"\treturn buf\n"
"}\n"
"",
"// Module for getting keyboard and mouse input.\n"
"// Keycodes are ascii chars (lower case) and the constants below.\n"
"//   mouse1\n"
"//   mouse2\n"
"//   mouse3\n"
"//   key_shift\n"
"//   key_backspace\n"
"//   key_delete\n"
"//   key_left\n"
"//   key_right\n"
"//   key_up\n"
"//   key_down\n"
"//   key_escape\n"
"//   key_enter\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"rect.um\"\n"
")\n"
"\n"
"const (\n"
"\tmouse1* =        char(1)\n"
"\tmouse2* =        char(2)\n"
"\tmouse3* =        char(3)\n"
"\tmouse_up* =      char(4)\n"
"\tmouse_down* =    char(5)\n"
"\tkey_shift* =     char(16)\n"
"\tkey_backspace* = char(8)\n"
"\tkey_delete* =    char(46)\n"
"\tkey_left* =      char(37)\n"
"\tkey_right* =     char(39)\n"
"\tkey_up* =        char(38)\n"
"\tkey_down* =      char(40)\n"
"\tkey_escape* =    char(27)\n"
"\tkey_enter* =     char(13)\t\n"
")\n"
"\n"
"fn cgetmouse(out: ^th.Vf2)\n"
"\n"
"// Returns the position of mouse cursor in relation to the screen.\n"
"fn getMousePos*(): th.Vf2 {\n"
"\tout := th.Vf2{}\n"
"\tcgetmouse(&out)\n"
"\treturn out\n"
"}\n"
"\n"
"// Returns the position of mouse cursor in relation to cam.\n"
"fn getGlobalMousePos*(cam: rect.Rect): th.Vf2 {\n"
"\treturn cam.toWorld(getMousePos())\n"
"}\n"
"\n"
"fn cispressed(keycode: char): int32\n"
"\n"
"fn cisjustpressed(key: char): int32\n"
"\n"
"// Returns true if key is pressed. Either use\n"
"// codes defined in the file above, or\n"
"// pass lower case char/number.\n"
"fn isPressed*(code: char): bool {\n"
"\tval := bool(cispressed(code))\n"
"\treturn val\n"
"}\n"
"\n"
"// Returns, whether code was just pressed\n"
"// this loop.\n"
"fn isJustPressed*(code: char): bool {\n"
"\treturn bool(cisjustpressed(code))\n"
"}\n"
"\n"
"fn cclear*(code: char)\n"
"// Clears both the pressed and justPressed state of a code.\n"
"fn clear*(code: char) {\n"
"\tcclear(code)\n"
"}\n"
"",
"// Misc functions.\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"std.um\"\t\t\t\t\t\t\t\n"
")\n"
"\n"
"// Reads file content into a string.\n"
"fn readall*(path: str): str {\n"
"\tf := std.fopen(path, \"r\")\n"
"\tconst blockSize = 16\n"
"\tres := \"\"\n"
"\n"
"\tfor ok := true; ok {\n"
"\t  var buff: [blockSize + 1]char\n"
"\t  ok = std.fread(f, ^[blockSize]char(&buff)) == 1\n"
"\t  res += str([]char(buff))\n"
"\t}\n"
"\n"
"\tstd.fclose(f)\n"
"\treturn res\n"
"}\n"
"\n"
"// Snaps a value to step.\n"
"fn stepify*(val, step: th.fu): th.fu {\n"
"\tif step != 0 {\n"
"\t\tval = trunc(val / step + 0.5) * step\n"
"\t}\n"
"\treturn val\n"
"}\n"
"",
"// Canvas library allowing for drawing basic shapes. Coordinates are based on\n"
"// the screen.\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"rect.um\"\n"
")\n"
"\n"
"// Draws a basic pixel text. Only ascii is supported.\n"
"fn drawText*(text: str, pos: th.Vf2, color: uint32, size: th.fu)\n"
"\n"
"// Returns the size of text taken by an equivalent drawText call.\n"
"fn textSize*(text: str, scale: th.fu): th.Vf2 {\n"
"\tvar w, maxw, h: int\n"
"\tw = 0\n"
"\tmaxw = 0\n"
"\th = 1\n"
"\t\n"
"\tfor i in text {\n"
"\t\tif text[i] == \"\\n\" {\n"
"\t\t\th += 1\n"
"\t\t\tif w > maxw {\n"
"\t\t\t\tmaxw = w\n"
"\t\t\t}\n"
"\n"
"\t\t\tcontinue\n"
"\t\t}\n"
"\n"
"\t\tw++\n"
"\t}\n"
"\n"
"\tif w > maxw {\n"
"\t\tmaxw = w\n"
"\t}\n"
"\n"
"\treturn th.Vf2{maxw * scale * 6 - scale, h * 6 * scale}\n"
"}\n"
"\n"
"// Draws a Rectangle.\n"
"fn drawRect*(color: uint32, r: rect.Rect)\n"
"\n"
"// Draws a line.\n"
"fn drawLine*(color: uint32, b, e: th.Vf2, thickness: th.fu)\n"
"",
"// This module will undergo changes.\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"ent.um\"\n"
"\t\"rect.um\"\n"
"\t\"canvas.um\"\n"
"\t\"tilemap.um\"\n"
")\n"
"\n"
"// Ray type.\n"
"type Ray* = struct {\n"
"\tpos: th.Vf2\n"
"\tl: th.fu // length\n"
"\tr: th.fu // rotation\n"
"}\n"
"\n"
"// Makes a ray.\n"
"fn mk*(pos: th.Vf2, l: th.fu, r: th.fu = 0.0): Ray {\n"
"\treturn Ray{pos, l, r}\n"
"}\n"
"\n"
"fn craygetcoll(colls: ^ent.Coll, count: ^int, maxCount,\n"
"\tsceneLen: int, r: ^Ray, scene: ^^ent.Ent)\n"
"fn craygettmapcoll(r: ^Ray, t: ^tilemap.Tilemap, ic: ^th.Vf2): bool\n"
"\n"
"// Same as ent.getcoll. Same changes will apply.\n"
"fn (r: ^Ray) getColl*(s: []^ent.Ent, maxColls: th.uu): []ent.Coll {\n"
"\tif len(s) == 0 {\n"
"\t\treturn []ent.Coll{}\n"
"\t}\n"
"\n"
"\tif maxColls > len(s) {\n"
"\t\tmaxColls = len(s)\n"
"\t}\n"
"\n"
"\tcolls := make([]ent.Coll, maxColls)\n"
"\tcount := 0\n"
"\tcraygetcoll(&colls[0], &count, maxColls, len(s), r, &s[0])\n"
"\treturn slice(colls, 0, count)\n"
"}\n"
"\n"
"// Gets ray\'s collision to a tilemap.\n"
"fn (r: ^Ray) getTilemapColl*(t: tilemap.Tilemap, ic: ^th.Vf2): bool {\n"
"\treturn craygettmapcoll(r, &t, ic)\n"
"}\n"
"\n"
"fn (r: ^Ray) draw*(cam: rect.Rect, color: uint32, thickness: th.fu) {\n"
"\tp1 := cam.toScreen(r.pos)\n"
"\tp2 := cam.toScreen(r.pos.add(th.Vf2{0, r.l}.rotated(th.Vf2{}, r.r)))\n"
"\tcanvas.drawLine(color, p1, p2, thickness)\n"
"}\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\t\n"
")\n"
"\n"
"// A set of points representing a rectangle.\n"
"type Rect* = struct {\n"
"\tx, y, w, h: th.fu\n"
"}\n"
"\n"
"fn mk*(x, y, w, h: th.fu): Rect {\n"
"\tvar r: Rect\n"
"\n"
"\tr.x = x\n"
"\tr.y = y\n"
"\tr.w = w\n"
"\tr.h = h\n"
"\n"
"\treturn r\n"
"}\n"
"\n"
"// translates screen coordinates to world coordinates with cam r\n"
"fn (r: ^rect.Rect) toWorld*(p: th.Vf2): th.Vf2 {\n"
"\treturn th.Vf2{ p.x + r.x - r.w/2, p.y + r.y - r.h/2 }\n"
"}\n"
"\n"
"// translates world coordinates to screen coordinates with cam r\n"
"fn (r: ^rect.Rect) toScreen*(p: th.Vf2): th.Vf2 {\n"
"\treturn th.Vf2{ p.x - r.x + r.w/2, p.y - r.y + r.h/2 }\n"
"}\n"
"\n"
"fn (r: ^rect.Rect) getPos*(): th.Vf2 {\n"
"\treturn th.Vf2{r.x, r.y}\n"
"}\n"
"\n"
"fn (r: ^rect.Rect) getDims*(): th.Vf2 {\n"
"\treturn th.Vf2{r.w, r.h}\n"
"}\n"
"",
"// Tilemaps allow for easy level construction and fast collisions. You can even\n"
"// use them for some games instead of entities (tetris comes to mind)\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"rect.um\"\n"
"\t\"ent.um\"\n"
"\t\"atlas.um\"\n"
")\n"
"\n"
"const (\n"
"\ttop* = 1\n"
"\tright* = 2\n"
"\tbot* = 4\n"
"\tleft* = 8\n"
")\n"
"\n"
"// Tilemap struct\n"
"type Tilemap* = struct {\n"
"\tatlas: atlas.Atlas\n"
"\tpos: th.Vf2\n"
"\tw: th.uu // width of tilemap\n"
"\tcells: []th.uu // all cells (this will draw the tile in tiles with number in cells - 1)\n"
"\tcollMask: []bool // if true, the tile collides\n"
"\tscale: th.fu\n"
"}\n"
"\n"
"fn mk*(cells: []th.uu, w: th.uu, at: atlas.Atlas, scale: th.fu = 1): Tilemap {\n"
"\tt := Tilemap{}\n"
"\tt.cells = cells\n"
"\tt.w = w\n"
"\tt.atlas = at\n"
"\tt.collMask = make([]bool, 10) //  TODO\n"
"\tt.scale = scale\n"
"\t\n"
"\treturn t\n"
"}\n"
"\n"
"// Sets tile at [x, y] to tile.\n"
"fn (t: ^Tilemap) edit*(x, y, tile: int) {\n"
"\tt.cells[y*t.w + x] = tile\n"
"}\n"
"\n"
"fn cdrawtmap(ct: ^Tilemap, cam: ^rect.Rect)\n"
"\n"
"// Draws the tilemap.\n"
"fn (t: ^Tilemap) draw*(cam: rect.Rect) {\n"
"\tif len(t.cells) == 0 { return }\n"
"\n"
"\tcdrawtmap(t, &cam)\n"
"}\n"
"\n"
"fn ctmapgetcoll(pos: ^th.Vf2, vert: ^th.uu, t: ^Tilemap, e: ^ent.Ent): int32\n"
"\n"
"// Checks, if t collides with e.\n"
"// pos is the tile index where the collision happened\n"
"// vert is which index collided\n"
"// You need to pass a valid pointer (TODO)\n"
"fn (t: ^Tilemap) getColl*(e: ent.Ent, vert: ^th.uu, pos: ^th.Vf2): bool {\n"
"\tif len(t.cells) == 0 { return false }\n"
"\n"
"\tc := ctmapgetcoll(pos, vert, t, &e)\n"
"\n"
"\treturn bool(c)\n"
"}\n"
"\n"
"fn cautotile(tgt: ^th.uu, w, h: th.uu, src, cfg: ^th.uu, tile: th.uu)\n"
"\n"
"// Autotile turns all `tile` tiles in `src` into tiles in `tileCfg`, so they\n"
"// follow up correctly. `tileCfg` is an array of 16 tiles. They are placed in\n"
"// a way where OR of all the places where the tile continues (top, right bot,\n"
"// right). The constants for them are defined in this file. Example:\n"
"// tileCfg[top | bot] = 21\n"
"// top | bot would look something like this: |\n"
"fn (t: ^Tilemap) autotile*(src, tileCfg: []th.uu, tile: th.uu) {\n"
"\tif len(tileCfg) < 16 {\n"
"\t\terror(\"autotile: tileCfg len isn\'t 16\'\")\n"
"\t}\n"
"\n"
"\tcautotile(&t.cells[0], t.w, len(t.cells)/t.w, &src[0], &tileCfg[0], tile)\n"
"}\n"
"",
"// Module for interacting with tophat. w and h variables store the size of the\n"
"// window.\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"canvas.um\"\n"
"\t\"rect.um\"\n"
"\t\"std.um\"\n"
")\n"
"\n"
"var (\n"
"\tstart, end, clockOffset: real\n"
"\tw*, h*: int32\n"
")\n"
"\n"
"fn wsetup(title: str, w, h: int)\n"
"fn clearframe()\n"
"fn getdimensions(w, h: ^int32)\n"
"fn swapbuffers()\n"
"fn handleinput(): bool\n"
"fn updatescaling(w, h, camw, camh: int32)\n"
"\n"
"// Sets up the engine and opens a window.\n"
"fn setup*(title: str = \"tophat game\", width: int = 400, height: int32 = 400) {\n"
"\tw, h = width, height\n"
"\twsetup(title, width, height)\n"
"\tclearframe()\n"
"\n"
"\tif std.getenv(\"HOME\") == \"\" {\n"
"\t\tth.platform = \"windows\"\n"
"\t}\n"
"\n"
"\tupdatescaling(width, height, width, height)\n"
"\n"
"\tclockOffset = std.clock() * 1000\n"
"\tstart = std.clock() * 1000\n"
"}\n"
"\n"
"// Cycle needs to be called every cycle. Pass the currently used camera, which\n"
"// i used to calculate tophat\'s scaling. It returns true, if the window is\n"
"// still running.\n"
"fn cycle*(cam: rect.Rect): bool {\n"
"\tcanvas.drawRect(th.black, rect.Rect{0, -h, w, h})\n"
"\tcanvas.drawRect(th.black, rect.Rect{-w, 0, w, h})\n"
"\tcanvas.drawRect(th.black, rect.Rect{0, cam.h, w, h})\n"
"\tcanvas.drawRect(th.black, rect.Rect{cam.w, 0, w, h})\n"
"\tswapbuffers()\n"
"\n"
"\tend = std.clock()*1000\n"
"\tth.delta = round(end - start)\n"
"\t// zero delta may cause incorrect behaviour\n"
"\tif th.delta == 0 { th.delta = 1 }\n"
"\n"
"\tstart = std.clock()*1000\n"
"\tth.time = round(start - clockOffset)\n"
"\n"
"\trunning := handleinput()\n"
"\tclearframe()\n"
"\tgetdimensions(&w, &h)\n"
"\n"
"\tupdatescaling(w, h, round(cam.w), round(cam.h))\n"
"\treturn running\n"
"}\n"
"\n"
"fn umth_window_begin_scissor(x, y: int, w, h: uint)\n"
"fn umth_window_end_scissor()\n"
"// Disable rendering outside of rect `r`\n"
"fn beginScissorRect*(r: rect.Rect) {\n"
"\tumth_window_begin_scissor(trunc(r.x), trunc(r.y), trunc(r.w), trunc(r.h))\n"
"}\n"
"\n"
"// Stops cropping\n"
"fn endScissor*() {\n"
"\tumth_window_end_scissor();\n"
"}\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"utf8.um\"\n"
"\t\"rect.um\"\n"
"\t\"input.um\"\n"
"\t\"canvas.um\"\n"
")\n"
"\n"
"const (\n"
"\teventUnknown* = 0\n"
"\teventHover*\n"
"\teventPress*\n"
"\teventJustPress*\n"
"\teventRelease*\n"
")\n"
"\n"
"type Theme* = struct {\n"
"\tfg, bg: uint32\n"
"\n"
"\tborderColor: uint32\n"
"\tborderSize: th.fu\n"
"}\n"
"\n"
"// A structure all elements have to contain. t can be set manually by the user,\n"
"// s being the dimensions, or it can be set by another elements. onEvent is an\n"
"// event callback. It will pass whatever is set in the ctx field.\n"
"// Event types:\n"
"// eventUnknown\n"
"// eventHover\n"
"// eventPress\n"
"// eventJustPress\n"
"// eventRelease\n"
"type Generic* = struct {\n"
"\tr: rect.Rect\n"
"\tgridPos: th.Vf2\n"
"\tgridSpan: th.Vf2\n"
"\ttheme: Theme\n"
"\n"
"\tctx: interface{}\n"
"\tonEvent: fn(eventType: th.uu, ctx: interface{})\n"
"\tpressed: bool\n"
"\tselected: bool\n"
"}\n"
"\n"
"// An interface every ui element has to implements.\n"
"type Element* = interface {\n"
"\thandle()\n"
"\tdraw()\n"
"\tget(): ^Generic\n"
"}\n"
"\n"
"// Interface used anywhere, where text is rendered.\n"
"type TextRenderer* = interface {\n"
"\tdraw(text: str, pos: th.Vf2, color: uint32, scale: th.fu = 1.0)\n"
"\tmeasure(text: str): th.Vf2\n"
"}\n"
"\n"
"// Bindings around canvas\'s font rendering functions to make them usable\n"
"// with the TextRenderer interface.\n"
"type PixelFont* = struct { }\n"
"fn (pf: ^PixelFont) draw*(text: str, pos: th.Vf2, color: uint32, scale: th.fu = 1.0) {\n"
"\tcanvas.drawText(text, pos, color, scale)\n"
"}\n"
"fn (pf: ^PixelFont) measure*(text: str): th.Vf2 {\n"
"\treturn canvas.textSize(text, 1)\n"
"}\n"
"\n"
"fn mkGeneric*(): Generic {\n"
"\tg := Generic{}\n"
"\tg.onEvent = fn(eventType: th.uu, ctx: interface{}) { }\n"
"\treturn g\n"
"}\n"
"\n"
"// Functions that sets the grid pos of a Generic\n"
"fn (g: ^Generic) grid*(x, y: th.uu): ^Generic {\n"
"\tg.gridPos.x = x\n"
"\tg.gridPos.y = y\n"
"\treturn g\n"
"}\n"
"\n"
"// Function setting the grid span of a Generic\n"
"fn (g: ^Generic) span*(x, y: th.uu): ^Generic {\n"
"\tg.gridSpan.x = x\n"
"\tg.gridSpan.y = y\n"
"\treturn g\n"
"}\n"
"\n"
"// Generic\'s handle function. It checks for events. If you create your own\n"
"// ui element and want to have more control over how events are fired, you\n"
"// don\'t have to use it.\n"
"fn (g: ^Generic) handle*() {\n"
"\tm := input.getMousePos()\n"
"\tif m.x < g.r.x || m.y < g.r.y ||\n"
"\t\tm.x > g.r.x + g.r.w || m.y > g.r.y + g.r.h {\n"
"\t\tif g.pressed {\n"
"\t\t\tg.pressed = false\n"
"\t\t\tg.onEvent(eventRelease, g.ctx)\n"
"\t\t}\n"
"\t\treturn\n"
"\t}\n"
"\t\n"
"\tg.onEvent(eventHover, g.ctx)\n"
"\t\n"
"\tif input.isPressed(input.mouse1) {\n"
"\t\tif !g.pressed {\n"
"\t\t\tg.onEvent(eventJustPress, g.ctx)\n"
"\t\t}\n"
"\n"
"\t\tg.onEvent(eventPress, g.ctx)\n"
"\t\tg.pressed = true\n"
"\t} else if g.pressed {\n"
"\t\tg.pressed = false\n"
"\t\tg.onEvent(eventRelease, g.ctx)\n"
"\t}\n"
"}\n"
"\n"
"fn drawBorder*(p, d: th.Vf2, t: Theme) {\n"
"\tcanvas.drawRect(t.borderColor, rect.mk(p.x, p.y, t.borderSize, d.y))\n"
"\tcanvas.drawRect(t.borderColor, rect.mk(p.x, p.y, d.x, t.borderSize))\n"
"\tcanvas.drawRect(t.borderColor, rect.mk(p.x + d.x - t.borderSize, p.y, t.borderSize, d.y))\n"
"\tcanvas.drawRect(t.borderColor, rect.mk(p.x, p.y + d.y - t.borderSize, d.x, t.borderSize))\n"
"}\n"
"",
"// Umka standard library\n"
"\n"
"// Memory\n"
"\n"
"fn rtlmemcpy(dest, src: ^void, count: int)\n"
"\n"
"fn tobytes*(buf: interface{}): []uint8 {\n"
"    if buf.__self == null {\n"
"        error(\"Buffer is null\")\n"
"    }\n"
"    if selfhasptr(buf) {\n"
"        error(\"Cannot access reference types\")\n"
"    }\n"
"    bytes := make([]uint8, sizeofself(buf))\n"
"    rtlmemcpy(&bytes[0], buf.__self, sizeofself(buf))\n"
"    return bytes\n"
"}\n"
"\n"
"fn frombytes*(buf: interface{}, bytes: []uint8) {\n"
"    if buf.__self == null {\n"
"        error(\"Buffer is null\")\n"
"    }    \n"
"    if selfhasptr(buf) {\n"
"        error(\"Cannot access reference types\")\n"
"    }\n"
"    if sizeofself(buf) != len(bytes) {\n"
"        error(\"Illegal buffer size\")\n"
"    }\n"
"    rtlmemcpy(buf.__self, &bytes[0], sizeofself(buf))    \n"
"}\n"
"\n"
"// File I/O\n"
"\n"
"type File* = ^struct {}\n"
"\n"
"const (\n"
"    seekBegin* = 0\n"
"    seekCur*   = 1\n"
"    seekEnd*   = 2\n"
")    \n"
"\n"
"fn rtlfopen  (name: str, mode: str): File;  \n"
"fn fopen*    (name: str, mode: str): File {return rtlfopen(name, mode)}\n"
"\n"
"fn rtlfclose (f: File): int\n"
"fn fclose*   (f: File): int {return rtlfclose(f)}\n"
"\n"
"fn rtlfread(buf: ^void, size, cnt: int, f: File): int\n"
"\n"
"fn fread*(f: File, buf: interface{}): int {\n"
"    if f == null {\n"
"        error(\"File is null\")\n"
"    }\n"
"    if bytes := ^[]uint8(buf); bytes != null {\n"
"        return rtlfread(&bytes[0], len(bytes^), 1, f)\n"
"    }\n"
"    if selfhasptr(buf) {\n"
"        error(\"Cannot read reference types except ^[]uint8\")\n"
"    }\n"
"    return rtlfread(buf.__self, sizeofself(buf), 1, f)\n"
"}\n"
"\n"
"fn rtlfwrite(buf: ^void, size, cnt: int, f: File): int\n"
"\n"
"fn fwrite*(f: File, buf: interface{}): int {\n"
"    if f == null {\n"
"        error(\"File is null\")\n"
"    }\n"
"    if bytes := ^[]uint8(buf); bytes != null {\n"
"        return rtlfwrite(&bytes[0], len(bytes^), 1, f)\n"
"    }    \n"
"    if selfhasptr(buf) {\n"
"        error(\"Cannot write reference types except ^[]uint8\")\n"
"    }\n"
"    return rtlfwrite(buf.__self, sizeofself(buf), 1, f)\n"
"}\n"
"\n"
"fn rtlfseek  (f: File, offset, origin: int): int\n"
"fn fseek*    (f: File, offset, origin: int): int {\n"
"    if f == null {\n"
"        error(\"File is null\")\n"
"    }\n"
"    return rtlfseek(f, offset, origin)\n"
"}\n"
"\n"
"fn rtlftell (f: File): int\n"
"fn ftell*   (f: File): int {\n"
"    if f == null {\n"
"        error(\"File is null\")\n"
"    }\n"
"    return rtlftell(f)\n"
"}\n"
"\n"
"fn rtlremove (name: str): int\n"
"fn remove*   (name: str): int {return rtlremove(name)}\n"
"\n"
"fn rtlfeof  (f: File): int\n"
"fn feof*    (f: File): bool {\n"
"    if f == null {\n"
"        error(\"File is null\")\n"
"    }                \n"
"    return bool(rtlfeof(f))\n"
"}\n"
"\n"
"// I/O utilities\n"
"\n"
"fn println*(s: str): int {return printf(\"%s\\n\", s)}\n"
"fn fprintln*(f: File, s: str): int {return fprintf(f, \"%s\\n\", s)}\n"
"\n"
"fn getchar*(): char {\n"
"    var c: char\n"
"    scanf(\"%c\", &c)\n"
"    return c\n"
"}\n"
"\n"
"// Strings\n"
"\n"
"fn ltrim*(s: str): str {\n"
"    start := -1\n"
"    slen := len(s)\n"
"    for i := 0; i < slen; i++ {\n"
"        if s[i] != \' \' && s[i] != \'\\t\' {\n"
"            start = i\n"
"            break\n"
"        } \n"
"    }\n"
"    if start == -1 {return \"\"}\n"
"    return slice(s, start)\n"
"}\n"
"\n"
"fn rtrim*(s: str): str {\n"
"    stop := -1\n"
"    slen := len(s)\n"
"    for i := slen - 1; i >= 0; i-- {\n"
"        if s[i] != \' \' && s[i] != \'\\t\' {\n"
"            stop = i\n"
"            break\n"
"        } \n"
"    }\n"
"    if stop == -1 {return \"\"}\n"
"    return slice(s, 0, stop + 1)\n"
"}\n"
"\n"
"fn trim*(s: str): str {\n"
"    return ltrim(rtrim(s))\n"
"}\n"
"\n"
"// Conversions\n"
"\n"
"fn atoi*(s: str): int {\n"
"    var x: int\n"
"    sscanf(s, \"%lld\", &x)\n"
"    return x\n"
"}\n"
"\n"
"fn atof*(s: str): real {\n"
"    var x: real\n"
"    sscanf(s, \"%lf\", &x)\n"
"    return x\n"
"}\n"
"\n"
"fn itoa*(x: int): str {\n"
"    s := str(make([]char, 256))\n"
"    sprintf(s, \"%lld\", x)\n"
"    return s\n"
"}\n"
"\n"
"fn ftoa*(x: real, decimals: int): str {\n"
"    fmt := str(make([]char, 256))\n"
"    s := str(make([]char, 256))\n"
"    sprintf(fmt, \"%%.%dlf\", decimals)\n"
"    sprintf(s, fmt, x)\n"
"    return s\n"
"}\n"
"\n"
"// Math\n"
"\n"
"const pi* = 3.14159265358979323846\n"
"\n"
"// Random numbers\n"
"\n"
"const randMax* = 0x7FFFFFFF\n"
"randSeed := 0\n"
"\n"
"fn srand*(seed: int) {randSeed = seed}\n"
"\n"
"fn rand*(): int {\n"
"    randSeed = ((randSeed * 1103515245) + 12345) & 0x7FFFFFFF\n"
"    return randSeed\n"
"}\n"
"\n"
"fn frand*(): real {return real(rand()) / randMax}\n"
"\n"
"// Timer\n"
"\n"
"fn rtltime(): int\n"
"fn time*(): int {return rtltime()}\n"
"\n"
"fn rtlclock(): real\n"
"fn clock*(): real {return rtlclock()}\n"
"\n"
"// Command line and environment\n"
"\n"
"fn argc*(): int {return rtlargc}\n"
"\n"
"fn argv*(i: int): str {\n"
"    if i < 0 || i >= rtlargc {\n"
"        error(\"Command line parameter not found\")\n"
"    }\n"
"    return rtlargv[i]\n"
"}\n"
"\n"
"fn rtlgetenv(name: str): str\n"
"fn getenv*(name: str): str {\n"
"    return \"\" + rtlgetenv(name)\n"
"}\n"
"\n"
"",
"// Particles allow for <i>performant</i> and random particle systems.\n"
"// TODO: a better constructor\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"rect.um\"\n"
")\n"
"\n"
"// Particle struct. You can tweak the start_time for godot-like explossivness.\n"
"type Particle* = struct {\n"
"\tstart_time: uint\n"
"\tseed: int32\n"
"}\n"
"\n"
"// Emitter. This is where everything is configured.\n"
"type Emitter* = struct {\n"
"\tpos: th.Vf2 // position\n"
"\tdm: th.Vf2 // size of the emittion area\n"
"\tgravity: th.Vf2 // gravity\n"
"\trepeat: bool // if false, particle won\'t be renewed\n"
"\tactive: bool // false, if there aren\'t any active particles anymore\n"
"\t\n"
"\tangle: th.Vf2 // angle in which particles are emitted\n"
"\n"
"\tlifetime: th.uu // lifetime of particles\n"
"\tlifetimeRandomness: th.fu // randomness in %/100\n"
"\n"
"\tvelocity: th.fu // velocity\n"
"\tvelocityRandomness: th.fu // randomness in %/100\n"
"\n"
"\tsize: th.fu // size\n"
"\tsizeRandomness: th.fu // randomness in %/100\n"
"\tmaxSize: th.fu // size at the end of particles lifetime\n"
"\n"
"\trotation: th.fu\n"
"\trotationRandomness: th.fu\n"
"\tmaxRotation: th.fu\n"
"\n"
"\tcolors: []uint32 // array of colors, which are interpolated between\n"
"\t\n"
"\tparticles: []Particle // list of particles\n"
"}\n"
"\n"
"fn c_particles_draw(p: ^Emitter, cam: ^rect.Rect, t: int32)\n"
"\n"
"// Draws and updates the particles.\n"
"fn (e: ^Emitter) draw*(cam: rect.Rect, t: int32) {\n"
"\tif len(e.colors) <= 0 || len(e.particles) <= 0 {\n"
"\t\treturn\n"
"\t}\n"
"\n"
"\tc_particles_draw(e, &cam, t)\n"
"}\n"
"",
"// <b>TO BE DELETED</b>\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"rect.um\"\n"
")\n"
"\n"
"// Mask is a set of dots that can be edited and drawn to emulate light.\n"
"// You can even edit the dots yourself, but it won\'t look good with multiple\n"
"// lights. A function for plotting a pixel will be available soon.\n"
"type Mask* = struct {\n"
"\tdots: []uint32\n"
"\tw, h: th.uu\n"
"\trectSize: th.fu\n"
"\tcolor: uint32\n"
"}\n"
"\n"
"type cmask = struct {\n"
"\tdots: ^uint32\n"
"\tw, h: th.uu\n"
"\trectsize: th.fu\n"
"\tcolor: uint32\n"
"}\n"
"\n"
"// A circular light that can be plotted onto a mask.\n"
"type Spotlight* = struct {\n"
"\tpos: th.Vf2\n"
"\tradius: th.uu\n"
"\ttint: uint32\n"
"}\n"
"\n"
"fn clightmaskclear(m: ^cmask)\n"
"\n"
"// Clears the lightmask to have it\'s own default color.\n"
"fn (m: ^Mask) clear*() {\n"
"\tcm := cmask {\n"
"\t\t&m.dots[0],\n"
"\t\tm.w, m.h, m.rectSize,\n"
"\t\tm.color}\n"
"\n"
"\tclightmaskclear(&cm)\n"
"}\n"
"\n"
"fn mk*(color: uint32, rectSize: real, cam: rect.Rect): Mask {\n"
"\td := Mask{}\n"
"\n"
"\td.rectSize = rectSize\n"
"\td.w = round(cam.w / rectSize)\n"
"\td.h = round(cam.h / rectSize)\n"
"\td.dots = make([]uint32, d.w * d.h)\n"
"\td.color = color\n"
"\n"
"\td.clear()\n"
"\n"
"\treturn d\n"
"}\n"
"\n"
"fn clightmaskdraw(m: ^cmask, cam: ^rect.Rect)\n"
"\n"
"// Draws a lightmask.\n"
"fn (m: ^Mask) draw*(cam: rect.Rect) {\n"
"\tcm := cmask {\n"
"\t\t&m.dots[0],\n"
"\t\tm.w, m.h, m.rectSize,\n"
"\t\tm.color}\n"
"\n"
"\tclightmaskdraw(&cm, &cam)\n"
"}\n"
"\n"
"fn cspotlightstamp(s: ^Spotlight, m: ^cmask, cam: ^rect.Rect)\n"
"\n"
"// Stamps a spotlight onto a mask.\n"
"fn (s: ^Spotlight) stamp*(m: ^Mask, cam: rect.Rect) {\n"
"\tcm := cmask {\n"
"\t\t&m.dots[0],\n"
"\t\tm.w, m.h, m.rectSize,\n"
"\t\tm.color}\n"
"\n"
"\tcspotlightstamp(s, &cm, &cam)\n"
"}\n"
"\n"
"",
"// Simple linear interpolation module.\n"
"\n"
"import (\n"
"\t\"th.um\"\t\t\t\t\t\t\t\t\n"
")\n"
"\n"
"type Any* = interface{}\n"
"\n"
"// Lerper queue item. It interpolates between start and end for the duration\n"
"// of length in ms. Additionally you can enable swap, which instead of\n"
"// dequeueing swaps start and end and resets the progress.\n"
"type Item* = struct {\n"
"\tstart, end: th.fu\n"
"\tlength: th.uu\n"
"\tprogress: th.fu\n"
"\tswap: bool\n"
"\tctx: Any\n"
"\tcallback: fn(ctx: Any)\n"
"}\n"
"\n"
"// Item\'s constructor\n"
"fn mk*(start, end: th.fu, length: th.uu, swap: bool = false): Item {\n"
"\treturn Item{\n"
"\t\tstart, end, length, 0, swap, null, fn(ctx: Any) {}}\n"
"}\n"
"\n"
"// Lerper is a queue of items. It will lerp the first one and if it ends\n"
"// and doesn\'t have swap enabled, it will dequeue it.\n"
"type Lerper* = []Item\n"
"\n"
"// Removes the first lerper item.\n"
"fn (l: ^Lerper) dequeue*() {\n"
"\tswitch len(l^) {\n"
"\tcase 0:\n"
"\t\treturn\n"
"\tcase 1:\n"
"\t\tl^ = Lerper{}\n"
"\tdefault:\n"
"\t\tl^ = slice(l^, 1)\n"
"\t}\n"
"}\n"
"\n"
"// Adds an item to l\'s queue\n"
"fn (l: ^Lerper) enqueue*(i: Item) {\n"
"\tl^ = append(l^, i)\n"
"}\n"
"\n"
"// Interpolates the front by delta. And returns it\'s value.\n"
"fn (l: ^Lerper) byDelta*(delta: th.uu): th.fu {\n"
"\tif len(l^) == 0 {\n"
"\t\treturn 0\n"
"\t}\n"
"\n"
"\t/*for l[0].progress >= 1.0 {\n"
"\t\tl[0].callback(l[0].ctx)\n"
"\n"
"\t\tif l[0].swap {\n"
"\t\t\ttmp := l[0].start\n"
"\t\t\tl[0].start = l[0].end\n"
"\t\t\tl[0].end = tmp\n"
"\n"
"\t\t\tl[0].progress = 0\n"
"\t\t\tbreak\n"
"\t\t}\n"
"\n"
"\t\tl.dequeue()\n"
"\t\tif len(l^) == 0 {\n"
"\t\t\treturn 0\n"
"\t\t}\n"
"\t}*/\n"
"\n"
"\tif l[0].progress >= 1 {\n"
"\t\tend := l[0].end\n"
"\t\tl.dequeue()\n"
"\t\treturn end\n"
"\t}\n"
"\n"
"\tl[0].progress += th.fu(delta)/l[0].length\n"
"\n"
"\treturn l[0].progress * (l[0].end-l[0].start) + l[0].start\n"
"}\n"
"",
"// UTF-8 utilities\n"
"\n"
"type (\n"
"\tRune* = int32\n"
")\n"
"\n"
"fn (r: ^Rune) size*(): int {\n"
"\tif r^ <= 0x7f {\n"
"\t\treturn 1\n"
"\t}\n"
"\n"
"\tif r^ <= 0x7ff {\n"
"\t\treturn 2\n"
"\t}\n"
"\n"
"\tif r^ <= 0xffff {\n"
"\t\treturn 3\n"
"\t}\n"
"\n"
"\tif r^ <= 0x10ffff {\n"
"\t\treturn 4\n"
"\t}\n"
"\n"
"\treturn 0\n"
"}\n"
"\n"
"fn (r: ^Rune) encode*(): str {\n"
"\ts := r.size()\n"
"\n"
"\tif s == 1 {\n"
"\t\treturn str(char(r^))\n"
"\t}\n"
"\n"
"\tout := make([]char, s + 1)\n"
"\n"
"\t// header is size amount of ones at the start\n"
"\theader := 0\n"
"\tfor i := 0; i < s; i++ {\n"
"\t\theader |= 1 << (7 - i)\n"
"\t}\n"
"\n"
"\tshift := (s - 1) * 6\n"
"\tout[0] = char(((r^ >> shift & 0xff) | header) & 0xff)\n"
"\n"
"\tfor i := 1; i < s; i++ {\n"
"\t\tshift -= 6\n"
"\t\tout[i] = char(r^ >> shift & 0x3f | 0x80)\n"
"\t}\n"
"\n"
"\treturn str(out)\n"
"}\n"
"\n"
"fn getNextRune*(a: str, pos: int): Rune\n"
"\n"
"fn decode*(s: str): []Rune {\n"
"\trunes := make([]Rune, len(s))\n"
"\truneCount := 0\n"
"\n"
"\tl := len(s)\n"
"\t\n"
"\tfor i := 0; i < l; runeCount++ {\n"
"\t\trunes[runeCount] = getNextRune(s, i)\n"
"\t\ti += runes[runeCount].size()\n"
"\t}\n"
"\n"
"\treturn slice(runes, 0, runeCount)\n"
"}\n"
"\n"
"fn realLength*(s: str): int {\n"
"\trl := 0\n"
"\tl := len(s)\n"
"\tfor i := 0; i < l; rl++ {\n"
"\t\tr := getNextRune(s, i)\n"
"\t\ti += r.size()\n"
"\t}\n"
"\n"
"\treturn rl\n"
"}\n"
"",
"// Module for font rendering. Unicode is supported, but only left to right.\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
")\n"
"\n"
"const (\n"
"\tfilterBilinear* = 0\n"
"\tfilterNearest* = 1\n"
")\n"
"\n"
"type Font* = struct { _: ^struct{} }\n"
"\n"
"fn cfontload(path: str, size: th.fu, filter: uint32): ^struct{}\n"
"fn cfontdraw(font: Font, s: str, x: th.fu, y: th.fu, color: uint32, scale: th.fu)\n"
"fn cfontmeasure(font: Font, s: str, o: ^th.Vf2)\n"
"\n"
"fn load*(path: str, size: th.fu, filter: uint32 = filterBilinear): Font {\n"
"\treturn Font{cfontload(path, size, filter)}\n"
"}\n"
"\n"
"fn (f: ^Font) draw*(text: str, pos: th.Vf2, color: uint32, scale: th.fu = 1.0) {\n"
"\tcfontdraw(f^, text, pos.x, pos.y, color, scale)\n"
"}\n"
"\n"
"fn (f: ^Font) validate*(): bool {\n"
"\treturn f._ != null\n"
"}\n"
"\n"
"fn (f: ^Font) measure*(text: str): th.Vf2 {\n"
"\tvar size: th.Vf2\n"
"\tcfontmeasure(f^, text, &size)\n"
"\treturn size\n"
"}",
"// Module with useful variables and types.\n"
"// Variables: time, delta, platform\n"
"// Constants: black, white, red, green, blue, yellow, magenta, cyan.\n"
"\n"
"import (\n"
"\t\"std.um\"\n"
")\n"
"\n"
"// standard type for real values\n"
"type fu* = real32\n"
"// standard type for integer values\n"
"type iu* = int16\n"
"// standard type for unsigned values\n"
"type uu* = uint16\n"
"\n"
"// vector 2\n"
"type Vf2* = struct {\n"
"\tx, y: fu\n"
"}\n"
"\n"
"// Vf2 constructor\n"
"fn mkVf2*(x: fu = 0, y: fu = 0): Vf2 {\n"
"\treturn Vf2{x, y}\n"
"}\n"
"\n"
"// rotates `p` around `origin` with `rot` in degrees\n"
"fn (p: ^th.Vf2) rotated*(origin: th.Vf2, rot: th.fu): th.Vf2 {\n"
"\tangle := (rot * std.pi) / 180\n"
"\n"
"\tpos := p^\n"
"\tpos.x -= origin.x\n"
"\tpos.y -= origin.y\n"
"\n"
"\tx := pos.x * cos(angle) - pos.y * sin(angle)\n"
"\ty := pos.x * sin(angle) + pos.y * cos(angle)\n"
"\n"
"\tpos.x = x + origin.x\n"
"\tpos.y = y + origin.y\n"
"\n"
"\treturn pos\n"
"}\n"
"\n"
"// distance between p1 and p2\n"
"fn (p1: ^th.Vf2) distanceTo*(p2: th.Vf2): th.fu {\n"
"\treturn std.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y))\n"
"}\n"
"\n"
"// Angle between p1 and p2\n"
"fn (p1: ^th.Vf2) angleTo*(p2: th.Vf2): real {\n"
"\tif p1.x == p2.x && p1.y == p2.y { return 0 }\n"
"\treturn atan2(p2.y - p1.y, p2.x - p1.x) * 180 / std.pi + 180\n"
"}\n"
"\n"
"// Absolute value of a vector.\n"
"fn (p: ^th.Vf2) abs*(): th.Vf2 {\n"
"\treturn th.Vf2{fabs(p.x), fabs(p.y)}\n"
"}\n"
"\n"
"// Rounds a vector.\n"
"fn (p: ^th.Vf2) round*(): th.Vf2 {\n"
"\treturn th.Vf2{round(p.x), round(p.y)}\n"
"}\n"
"\n"
"// Truncates a vector.\n"
"fn (p: ^th.Vf2) trunc*(): th.Vf2 {\n"
"\treturn th.Vf2{trunc(p.x), trunc(p.y)}\n"
"}\n"
"\n"
"// Floors a vector.\n"
"fn (p: ^th.Vf2) floor*(): th.Vf2 {\n"
"\treturn th.Vf2{floor(p.x), floor(p.y)}\n"
"}\n"
"\n"
"// Ceils a vector.\n"
"fn (p: ^th.Vf2) ceil*(): th.Vf2 {\n"
"\treturn th.Vf2{ceil(p.x), ceil(p.y)}\n"
"}\n"
"\n"
"// Creates a vector with both x and y set to f\n"
"fn vf2f*(f: th.fu): th.Vf2 {\n"
"\treturn th.Vf2{f, f}\n"
"}\n"
"\n"
"// Subtracts a vector from another one.\n"
"fn (p: ^th.Vf2) sub*(p2: th.Vf2): th.Vf2 {\n"
"\treturn th.Vf2{p.x - p2.x, p.y - p2.y}\n"
"}\n"
"\n"
"// Subtracts a fu from a vector.\n"
"fn (p: ^th.Vf2) subf*(f: th.fu): th.Vf2 {\n"
"\treturn th.Vf2{p.x - f, p.y - f}\n"
"}\n"
"\n"
"// Adds a vector to another one.\n"
"fn (p: ^th.Vf2) add*(p2: th.Vf2): th.Vf2 {\n"
"\treturn th.Vf2{p.x + p2.x, p.y + p2.y}\n"
"}\n"
"\n"
"// Adds a fu to a vector.\n"
"fn (p: ^th.Vf2) addf*(f: th.fu): th.Vf2 {\n"
"\treturn th.Vf2{p.x + f, p.y + f}\n"
"}\n"
"\n"
"// Divides a vector by another one.\n"
"fn (p: ^th.Vf2) div*(p2: th.Vf2): th.Vf2 {\n"
"\treturn th.Vf2{p.x / p2.x, p.y / p2.y}\n"
"}\n"
"\n"
"// Divides a vector by a fu.\n"
"fn (p: ^th.Vf2) divf*(f: th.fu): th.Vf2 {\n"
"\treturn th.Vf2{p.x / f, p.y / f}\n"
"}\n"
"\n"
"// Multiplies a vector by another one.\n"
"fn (p: ^th.Vf2) mul*(p2: th.Vf2): th.Vf2 {\n"
"\treturn th.Vf2{p.x * p2.x, p.y * p2.y}\n"
"}\n"
"\n"
"// Multiplies a vector by a fu.\n"
"fn (p: ^th.Vf2) mulf*(f: th.fu): th.Vf2 {\n"
"\treturn th.Vf2{p.x * f, p.y * f}\n"
"}\n"
"\n"
"// Returns the magnitude of a vector p.\n"
"fn (p: ^th.Vf2) mag*(): th.fu {\n"
"\treturn sqrt(p.x * p.x + p.y * p.y)\n"
"}\n"
"\n"
"// Normalizes a vector.\n"
"fn (p: ^th.Vf2) norm*(): th.Vf2 {\n"
"\tif p.x == 0 && p.y == 0 {\n"
"\t\treturn p^\n"
"\t}\n"
"\n"
"\treturn p.divf(p.mag())\n"
"}\n"
"\n"
"// Calculates dot product between 2 vectors.\n"
"fn (p: ^th.Vf2) dot*(q: th.Vf2): fu {\n"
"\treturn p.x*q.x + p.y*q.y\n"
"}\n"
"\n"
"// Struct defining transformation. Used for example by entities.\n"
"type Transform* = struct {\n"
"\tp: Vf2 // position\n"
"\ts: Vf2 // scale\n"
"\to: Vf2 // origin\n"
"\tr: fu  // rotation\n"
"}\n"
"\n"
"// Transform constructor\n"
"fn mkTransform*(p: Vf2, s: Vf2 = Vf2{1, 1}, o: Vf2 = Vf2{0, 0}, r: fu = 0.0): Transform {\n"
"\treturn Transform{p: p, s: s, o: o, r: r}\n"
"}\n"
"\n"
"const (\n"
"\tblack* = 0xff\n"
"\twhite* = 0xffffffff\n"
"\tred* = 0xff0000ff\n"
"\tgreen* = 0x00ff00ff\n"
"\tblue* = 0x0000ffff\n"
"\tyellow* = 0xffff00ff\n"
"\tmagenta* = 0xff00ffff\n"
"\tcyan* = 0x00ffffff\n"
")\n"
"\n"
"var (\n"
"\ttime*: uint\n"
"\tdelta*: int\n"
"\tplatform*: str = \"linux\"\n"
")\n"
"",
"// A module for importless communication between modules. A signal is an array\n"
"// of callbacks with a name.\n"
"\n"
"type Any* = interface{}\n"
"type Callback* = fn(ctx: Any) \n"
"type Signal* = []Callback\n"
"\n"
"var signals: map[str]Signal\n"
"\n"
"// Registers a callback to a signal. There is no need to explicitely create\n"
"// signals.\n"
"fn register*(name: str, callback: Callback) {\n"
"\tif !valid(signals) {\n"
"\t\tsignals = make(map[str]Signal)\n"
"\t}\n"
"\n"
"\tif !validkey(signals, name) {\n"
"\t\tsignals[name] = Signal{callback}\n"
"\t} else {\n"
"\t\tsignals[name] = append(signals[name], callback)\n"
"\t}\n"
"}\n"
"\n"
"// Calls all callbacks associated with the passed name.\n"
"fn emit*(name: str, ctx: Any) {\n"
"\tif !valid(signals) {\n"
"\t\tsignals = make(map[str]Signal)\n"
"\t}\n"
"\n"
"\tfor i, c in signals[name] {\n"
"\t\tc(ctx)\n"
"\t}\n"
"}\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"image.um\"\n"
")\n"
"\n"
"// Atlas is an image containing tiles in a square grid.\n"
"type Atlas* = struct {\n"
"\ti: image.Image // source image\n"
"\tcs: th.Vf2 // size of a cell in pixels\n"
"\tdm: th.Vf2 // amount of cells in image\n"
"}\n"
"\n"
"// i: source image\n"
"// dm: amount of cells\n"
"fn mk*(i: image.Image, dm: th.Vf2): Atlas {\n"
"\ta := atlas.Atlas{}\n"
"\n"
"\ta.i = i\n"
"\ta.dm = dm\n"
"\ta.cs = i.getDims().div(dm)\n"
"\n"
"\treturn a\n"
"}\n"
"\n"
"// returns the coordinates of the nth tile\n"
"fn (a: ^Atlas) coords*(n: int): th.Vf2 {\n"
"\treturn th.Vf2{ n % trunc(a.dm.x), (n - n % trunc(a.dm.x)) / a.dm.x }\n"
"}\n"
"\n"
"// Crops the sourse image to only show a wanted tile\n"
"fn (a: ^Atlas) cropSource*(at: th.Vf2) {\n"
"\tif (at.x > a.dm.x || at.y > a.dm.y || at.x * at.y < 0) {\n"
"\t\treturn\n"
"\t}\n"
"\n"
"\ta.i.crop(\n"
"\t\tth.Vf2{at.x / a.dm.x, at.y / a.dm.y},\n"
"\t\tth.Vf2{(at.x+1) / a.dm.x, (at.y+1) / a.dm.y})\n"
"}\n"
"\n"
"// Draws the tile at `at`\n"
"fn (a: ^Atlas) draw*(at: th.Vf2, t: th.Transform) {\n"
"\ta.cropSource(at)\n"
"\ta.i.draw(t, th.white)\n"
"\ta.i.crop(th.Vf2{}, th.Vf2{1, 1})\n"
"}\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"utf8.um\"\n"
"\t\"rect.um\"\n"
"\t\"../ui.um\"\n"
"\t\"canvas.um\"\n"
")\n"
"\n"
"// An element containing a TextRenderer. The text renderer supports\n"
"// word-wrapping and centered text.\n"
"type Label* = struct {\n"
"\tg: ui.Generic\n"
"\ttext: str\n"
"\trenderer: ui.TextRenderer\n"
"\tcenter: bool\n"
"\twrapping: bool\n"
"\tscale: th.fu\n"
"}\n"
"\n"
"// Label constructor\n"
"fn mk*(f: ui.TextRenderer, text: str, theme: ui.Theme, scale: th.fu, center: bool = false, wrapping: bool = false): Label {\n"
"\tl := Label{}\n"
"\tl.g = ui.mkGeneric()\n"
"\tl.g.theme = theme\n"
"\tl.text = text\n"
"\tl.renderer = f\n"
"\tl.scale = scale\n"
"\tl.center = center\n"
"\tl.wrapping = wrapping\n"
"\n"
"\treturn l\n"
"}\n"
"\n"
"fn (l: ^Label) get*(): ^ui.Generic {\n"
"\treturn &l.g\n"
"}\n"
"\n"
"fn (l: ^Label) handle*() {\n"
"\tl.g.handle()\n"
"}\n"
"\n"
"fn (l: ^Label) draw*() {\n"
"\tif len(l.text) == 0 {\n"
"\t\treturn\n"
"\t}\n"
"\n"
"\tcanvas.drawRect(l.g.theme.bg, rect.Rect{l.g.r.x, l.g.r.y, l.g.r.w, l.g.r.h})\n"
"\tui.drawBorder(l.g.r.getPos(), l.g.r.getDims(), l.g.theme)\n"
"\n"
"\ttext := utf8.decode(l.text)\n"
"\t// hack to wrap the last word too\n"
"\ttext = append(text, uint32(\' \'))\n"
"\tlineCount := 1\n"
"\n"
"\tlines := [][]utf8.Rune{}\n"
"\n"
"\tif l.wrapping {\n"
"\t\tlimit := l.g.r.w - l.g.theme.borderSize * 2\n"
"\t\twordStart := 0\n"
"\t\tlineWidth := 0.0\n"
"\n"
"\t\tfor i:=0; i < len(text); i++ {\n"
"\t\t\tif text[i] == uint32(\' \') {\n"
"\t\t\t\tif lineWidth > limit {\n"
"\t\t\t\t\tlines = append(lines, slice(text, 0, wordStart))\n"
"\t\t\t\t\ttext = slice(text, wordStart - 1)\n"
"\n"
"\t\t\t\t\twordStart = 0\n"
"\t\t\t\t\tlineWidth = 0\n"
"\t\t\t\t\ti = -1\n"
"\t\t\t\t\tcontinue\n"
"\t\t\t\t}\n"
"\n"
"\t\t\t\twordStart = i + 1\n"
"\t\t\t\tlineWidth += l.renderer.measure(\" \").x * l.scale\n"
"\t\t\t} else if text[i] == uint32(\'\\n\') {\n"
"\t\t\t\tlines = append(lines, slice(text, 0, i))\n"
"\t\t\t\ttext = slice(text, i + 1)\n"
"\n"
"\t\t\t\twordStart = 0\n"
"\t\t\t\tlineWidth = 0\n"
"\t\t\t\ti = -1\n"
"\t\t\t} else {\n"
"\t\t\t\tlineWidth += l.renderer.measure(text[i].encode()).x * l.scale\n"
"\t\t\t}\n"
"\t\t}\n"
"\n"
"\t\t// we have to remove the space again to prevent alignment issues\n"
"\t\tlines = append(lines, slice(text, 0, len(text) - 1))\n"
"\t} else {\n"
"\t\tlines = append(lines, text)\n"
"\t}\n"
"\n"
"\tx := l.g.r.x + l.g.theme.borderSize\n"
"\ty := l.g.r.y\n"
"\tif l.center {\n"
"\t\ty += (l.g.r.h - len(lines) * l.renderer.measure(\"A\").y * l.scale) / 2\n"
"\t}\n"
"\n"
"\tfor i in lines {\n"
"\t\ts := \"\"\n"
"\t\tfor j in lines[i] {\n"
"\t\t\ts += lines[i][j].encode()\n"
"\t\t}\n"
"\n"
"\t\tp := th.Vf2{\n"
"\t\t\tx: x,\n"
"\t\t\ty: y }\n"
"\n"
"\t\tif l.center {\n"
"\t\t\tp.x += (l.g.r.w - l.renderer.measure(s).x * l.scale) / 2 + l.g.theme.borderSize / 2\n"
"\t\t}\n"
"\n"
"\t\tl.renderer.draw(s, p, l.g.theme.fg, l.scale)\n"
"\n"
"\t\ty += l.renderer.measure(s).y * l.scale\n"
"\t}\n"
"}\n"
"\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"ui.um\"\n"
")\n"
"\n"
"// A Grid container. The grid size is fixed, not dynamic like in Tk.\n"
"type Grid* = struct {\n"
"\tg: ui.Generic\n"
"\tw, h: th.uu\n"
"\tborder: th.fu\n"
"\telements: []ui.Element\n"
"}\n"
"\n"
"// Grid\'s constructor\n"
"fn mk*(w, h: th.uu, border: th.fu = 0): Grid {\n"
"\treturn Grid {\n"
"\t\tg: ui.mkGeneric(),\n"
"\t\tw: w, h: h, border: border}\n"
"}\n"
"\n"
"fn (g: ^Grid) get*(): ^ui.Generic {\n"
"\treturn &g.g\n"
"}\n"
"\n"
"fn (g: ^Grid) handle*() {\n"
"\tcellSize := th.Vf2{g.g.r.w/g.w, g.g.r.h/g.h}\n"
"\n"
"\tfor i:=0; i < len(g.elements); i++ {\n"
"\t\te := &g.elements[i]\n"
"\t\tge := e.get()\n"
"\n"
"\t\tif ge.gridPos.x > g.w || ge.gridPos.y > g.h {\n"
"\t\t\terror(\"ui.Grid: out of bounds.\")\n"
"\t\t}\n"
"\n"
"\t\tge.r.x = ge.gridPos.x * cellSize.x\n"
"\t\tge.r.y = ge.gridPos.y * cellSize.y\n"
"\t\t// divide by to as there are two borders\n"
"\t\tge.r.x += g.border/2 + g.g.r.x\n"
"\t\tge.r.y += g.border/2 + g.g.r.y\n"
"\n"
"\t\tif ge.gridPos.x + ge.gridSpan.x > g.w ||\n"
"\t\t\tge.gridPos.y + ge.gridSpan.y > g.h {\n"
"\t\t\terror(\"ui.Grid: out of bounds.\")\n"
"\t\t}\n"
"\n"
"\t\tif ge.gridSpan.x == 0 {\n"
"\t\t\tge.gridSpan.x = 1\n"
"\t\t}\n"
"\n"
"\t\tif ge.gridSpan.y == 0 {\n"
"\t\t\tge.gridSpan.y = 1\n"
"\t\t}\n"
"\n"
"\t\tge.r.w = ge.gridSpan.x * cellSize.x\n"
"\t\tge.r.h = ge.gridSpan.y * cellSize.y\n"
"\t\t// don\'t divide by two as size is relative to position\n"
"\t\tge.r.w -= g.border\n"
"\t\tge.r.h -= g.border\n"
"\n"
"\t\te.handle()\n"
"\t}\n"
"}\n"
"\n"
"fn (g: ^Grid) draw*() {\n"
"\tfor i, e in g.elements {\n"
"\t\te.draw()\n"
"\t}\n"
"}\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\n"
"\t\"ui.um\"\n"
"\t\"image.um\"\n"
")\n"
"\n"
"// An element containing an image\n"
"type Image* = struct {\n"
"\tg: ui.Generic\n"
"\timage: image.Image\n"
"\tstretch: bool\n"
"}\n"
"\n"
"fn mk*(i: image.Image, stretch: bool = false): Image {\n"
"\treturn Image {\n"
"\t\tg: ui.Generic{},\n"
"\t\timage: i,\n"
"\t\tstretch: stretch}\n"
"}\n"
"\n"
"fn (i: ^Image) get*(): ^ui.Generic {\n"
"\treturn &i.g\n"
"}\n"
"\n"
"fn (i: ^Image) handle*() {\n"
"\ti.g.handle()\n"
"}\n"
"\n"
"fn (i: ^Image) draw*() {\n"
"\tdm := i.image.getDims()\n"
"\ts := th.Vf2{}\n"
"\tif i.stretch {\n"
"\t\ts.x = i.g.r.w/dm.x\n"
"\t\ts.y = i.g.r.h/dm.y\n"
"\t} else {\n"
"\t\tif i.g.r.w < i.g.r.h {\n"
"\t\t\ts.x = i.g.r.w/dm.x\n"
"\t\t\ts.y = s.x\n"
"\t\t\ti.g.r.y += (i.g.r.h - s.y*dm.y)/2\n"
"\t\t} else {\n"
"\t\t\ts.y = i.g.r.h/dm.y\n"
"\t\t\ts.x = s.y\n"
"\t\t\ti.g.r.x += (i.g.r.w - s.x*dm.x)/2\n"
"\t\t}\n"
"\t}\n"
"\n"
"\ti.image.draw(th.Transform{p: i.g.r.getPos(), s: s}, th.white)\n"
"}\n"
"\n"
"",
"\n"
"import (\n"
"\t\"th.um\"\n"
")\n"
"\n"
"// Shader allows you to define your own vertex and fragment GLSL shaders. This\n"
"// is a low-level feature, so it\'s very easy to mess up.\n"
"//  \n"
"// In tophat, instead of a main function, shaders provide th_vertex and\n"
"// th_fragment. The signature of th_vertex is:\n"
"// vec2 th_vertex(vec2 vert);\n"
"// where vert is the position of the vertex taken from the vertex buffer.\n"
"// The output is the vertex shader output.\n"
"//  \n"
"// As for fragment shaders, there are two types of them. One for canvas\n"
"// and one for images. In canvas shaders, the fragment function is very simple:\n"
"// vec4 th_fragment(vec4 color);\n"
"//  \n"
"// Image fragment function looks like this:\n"
"// vec4 th_fragment(sampler2D tex, vec2 coord);\n"
"// where tex is the texture and coord are the texture coordinates. Be aware to\n"
"// swap the output of the texture2D function. Example:\n"
"// texture2D(tex, coord).abgr\n"
"type Shader* = struct {\n"
"\thandle: int\n"
"}\n"
"\n"
"const (\n"
"\tdefaultImageShader* = Shader{1}\n"
"\tdefaultCanvasShader* = Shader{2}\n"
")\n"
"\n"
"// Represents a GLSL uniform.\n"
"type Uniform* = struct {\n"
"\ts: Shader\n"
"\tl: uint\n"
"}\n"
"\n"
"fn ccompilecanvasshader(vertex, fragment: str): int\n"
"\n"
"// Compiles a canvas shader from source. If there is a compilation error, it\n"
"// will print something to the console.\n"
"fn mkCanvas*(vertex, fragment: str): Shader {\n"
"\treturn Shader{ccompilecanvasshader(vertex, fragment)}\n"
"}\n"
"\n"
"fn ccompileimageshader(vertex, fragment: str): int\n"
"\n"
"// Compiles an image shader from source. If there is a compilation error, it\n"
"// will print something to the console.\n"
"fn mkImage*(vertex, fragment: str): Shader {\n"
"\treturn Shader{ccompileimageshader(vertex, fragment)}\n"
"}\n"
"\n"
"fn cpickcanvasshader(handle: int)\n"
"\n"
"// Picks the shader to be used for canvas drawing. Flushes the canvas batch.\n"
"fn (s: ^Shader) pickForCanvas*() {\n"
"\tcpickcanvasshader(s.handle)\n"
"}\n"
"\n"
"fn cpickimageshader(handle: int)\n"
"\n"
"// Picks the shader to be used for image drawing. Flushes the image batch.\n"
"fn (s: ^Shader) pickForImage*() {\n"
"\tcpickimageshader(s.handle)\n"
"}\n"
"\n"
"fn cgetuniformlocation(handle: int, name: str): uint\n"
"\n"
"// Retunrs a uniform by name.\n"
"fn (s: ^Shader) getUniformLocation*(name: str): Uniform {\n"
"\treturn Uniform{s^, cgetuniformlocation(s.handle, name)}\n"
"}\n"
"\n"
"fn csetuniformint(shandle, uhandle: uint, value: int)\n"
"\n"
"// Sets a uniform to an int value. Flushes both batches.\n"
"fn (u: ^Uniform) setInt*(value: int) {\n"
"\tcsetuniformint(u.s.handle, u.l, value)\n"
"}\n"
"\n"
"fn csetuniformvf2(shandle, uhandle: uint, value: th.Vf2)\n"
"\n"
"// Sets a uniform to a vf2. Flushes both batches.\n"
"fn (u: ^Uniform) setVf2*(value: th.Vf2) {\n"
"\tcsetuniformvf2(u.s.handle, u.l, value)\n"
"}\n"
"",
"// Color operations. Operate on RGBA uint32 values.\n"
"\n"
"import (\n"
"\t\"th.um\"\n"
")\n"
"\n"
"fn umth_hsv2rgb_uint32(h, s, v, a: th.fu): uint32\n"
"\n"
"// Now this is hard to decide, but in my opinion executing a C function,\n"
"//   for the current Umka VM would be much better than implementing it in umka itself.\n"
"// It\'s somewhat less trivial than most other operations like alpha.\n"
"fn umth_rgb_uint32(r, g, b, a: th.fu): uint32\n"
"\n"
"// Converts HSV values into RGBA uint32 color.\n"
"// NOTE: Hue is between 0 and 1\n"
"fn hsv*(h, s, v: th.fu, a: th.fu = 1.0): uint32 {\n"
"\treturn umth_hsv2rgb_uint32(h, s, v, a);\n"
"}\n"
"\n"
"// Sets alpha of the color c to a value in to.\n"
"fn alpha*(c: uint32, to: th.fu): uint32 {\n"
"\treturn (c & 0xFFFFFF00) | (trunc(to * 255) & 0xFF)\n"
"}\n"
"\n"
"// Constructs RGBA uint32 from RGBA of reals.\n"
"fn rgb*(r, g, b: th.fu, a: th.fu = 1.0): uint32 {\n"
"\treturn umth_rgb_uint32(r, g, b, a)\n"
"}\n"
"\n"
"",
};
const char *th_em_modulenames[] = { "anim.um", "audio.um", "csv.um", "ent.um", "image.um", "input.um", "misc.um", "canvas.um", "ray.um", "rect.um", "tilemap.um", "window.um", "ui.um", "std/std.um", "particles.um", "light.um", "lerp.um", "utf8.um", "font.um", "th.um", "signal.um", "atlas.um", "ui/label.um", "ui/grid.um", "ui/imagebox.um", "shader.um", "color.um",  };
int th_em_modulenames_count = 27;
const char *th_em_misc[] = {
"BSD 3-Clause License\n"
"\n"
"Copyright (c) 2021, Marek Maskarinec\n"
"All rights reserved.\n"
"\n"
"Redistribution and use in source and binary forms, with or without\n"
"modification, are permitted provided that the following conditions are met:\n"
"\n"
"1. Redistributions of source code must retain the above copyright notice, this\n"
"   list of conditions and the following disclaimer.\n"
"\n"
"2. Redistributions in binary form must reproduce the above copyright notice,\n"
"   this list of conditions and the following disclaimer in the documentation\n"
"   and/or other materials provided with the distribution.\n"
"\n"
"3. Neither the name of the copyright holder nor the names of its\n"
"   contributors may be used to endorse or promote products derived from\n"
"   this software without specific prior written permission.\n"
"\n"
"THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n"
"AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n"
"IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n"
"DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n"
"FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n"
"DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n"
"SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n"
"CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n"
"OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n"
"OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
"",
"v0.7\n"
"",
};
