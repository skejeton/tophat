
import (
	"th.um"
	"utf8.um"
	"rect.um"
	"../ui.um"
	"canvas.um"
)

// An element containing a TextRenderer. The text renderer supports
// word-wrapping and centered text.
type Label* = struct {
	g: ui.Generic
	text: str
	renderer: ui.TextRenderer
	center: bool
	wrapping: bool
	scale: th.fu
}

// Label constructor
fn mk*(f: ui.TextRenderer, text: str, theme: ui.Theme, scale: th.fu, center: bool = false, wrapping: bool = false): Label {
	l := Label{}
	l.g = ui.mkGeneric()
	l.g.theme = theme
	l.text = text
	l.renderer = f
	l.scale = scale
	l.center = center
	l.wrapping = wrapping

	return l
}

fn (l: ^Label) get*(): ^ui.Generic {
	return &l.g
}

fn (l: ^Label) handle*() {
	l.g.handle()
}

fn (l: ^Label) draw*() {
	if len(l.text) == 0 {
		return
	}

	canvas.drawRect(l.g.theme.bg, rect.Rect{l.g.r.x, l.g.r.y, l.g.r.w, l.g.r.h})
	ui.drawBorder(l.g.r.getPos(), l.g.r.getDims(), l.g.theme)
	text := utf8.decode(l.text)
	lineCount := 1

	if l.wrapping {
		maxW := l.g.r.w
		w := 0.0
		wordW := 0.0
		lastSpace := 0
		for i:=0; i < len(text); i++ {
			if text[i] == uint32(' ') {
				lastSpace = i
				step := l.renderer.runeDims(uint32('A')).x * l.scale * 1.1
				w += step
				if wordW > maxW {
					text[i] = uint32('\n')
					w = 0
				}
				wordW = 0
			} else {
				step := l.renderer.runeDims(text[i]).x * l.scale * 1.1
				w += step
				wordW += step
			}

			if text[i] == uint32('\n') {
				w = 0
			}
 
			if w >= maxW && wordW < maxW {
				i = lastSpace
				text[i] = uint32('\n')
				w = 0
				lineCount++
			}
		}
	}

	stext := ""
	w := 0.0
	lineH := -1.0
	origY := l.g.r.y
	p := l.g.r.getPos()

	if l.center {
		p.y += (l.g.r.h - l.renderer.runeDims(utf8.Rune('A')).y*lineCount*l.scale)/2
	}
	
	for i:=0; true; i++ {
		if i >= len(text) || text[i] == uint32('\n') {
			if l.center {
				p.x = (l.g.r.w - w) / 2
			}
			l.renderer.draw(stext, th.Vf2{p.x + l.g.r.x, p.y}, l.g.theme.fg, l.scale)

			stext = ""
			p.y += lineH * l.scale * 1.6
			if p.y + lineH*l.scale*1.8 > origY + l.g.r.h {
				return
			}
			w = 0
			if i >= len(text) { break }
			continue
		}

		if text[i] == uint32(' ') {
			w += l.renderer.runeDims(uint32('A')).x * l.scale * 1.1
		} else {
			dm := l.renderer.runeDims(text[i]).x
			w += dm * l.scale * 1.1
			if h := dm; lineH == -1 || h > lineH {
				lineH = h
			}
		}

		stext += text[i].encode()
	}
}

