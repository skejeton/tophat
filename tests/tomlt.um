/**
 * Toml tests (umka/toml.um)
 */

import ("toml.um"; "std.um")

fail := false

fn readFileStr(path: str): (bool, str) {
  file := std.fopen(path, "r")
  if file == null {
    return false, ""
  }
  std.fseek(file, 0, std.seekEnd)
  datasiz := std.ftell(file)
  std.fseek(file, 0, std.seekBegin)

  data := make([]char, datasiz+1)
  std.fread(file, data)
  
  return true, data
}

fn expectToEqual(a, b: str) {
	if a != b {
		error(sprintf("'%s' != '%s'", a, b))
	}
	printf("Ok\n")
}

fn expectToEqualInt(a, b: int) {
  if a != b {
    error(sprintf("'%d' != '%d'", a, b))
  }
  printf("Ok\n")
}

fn expectToEqualReal(a, b: real) {
  if a != b {
    error(sprintf("'%g' != '%g'", a, b))
  }
  printf("Ok\n")
}

fn expectToEqualBool(a, b: bool) {
  if a != b {
    error(sprintf("%s != %s", repr(a), repr(b)))
  }
  printf("Ok\n")
}

fn errorTest(path: str, errcode: int) {
  if ok, input := readFileStr(path); ok {
    result := toml.parse(input)
    if error := result.getError(); error != null {
      printf("%s\n", toml.formatError(error, input))
      if error.code == errcode {
        printf("Ok\n")
        return 
      }
    }
  }

  fail = true
  printf("FAIL\n")
}

fn main() {
  printf(">>> Check errors\n")
  errorTest("tests/toml/error_unclosed_string_0.toml", toml.errUnclosedString)
  errorTest("tests/toml/error_unclosed_string_1.toml", toml.errUnclosedString)
  errorTest("tests/toml/error_unexpected_token_0.toml", toml.errUnexpectedToken)
  errorTest("tests/toml/error_expected_newline_0.toml", toml.errExpectedNewLine)
  errorTest("tests/toml/error_invalid_token_for_key_0.toml", toml.errExpectedKey)
  errorTest("tests/toml/error_invalid_token_for_key_1.toml", toml.errExpectedKey)
  errorTest("tests/toml/error_unexpected_character_1.toml", toml.errUnexpectedCharacter)
  errorTest("tests/toml/error_unexpected_character_1.toml", toml.errUnexpectedCharacter)
  errorTest("tests/toml/error_field_reassigned_0.toml", toml.errFieldReassigned)
  errorTest("tests/toml/error_field_reassigned_1.toml", toml.errFieldReassigned)


  printf(">>> Verify correct tree\n")
	if ok, input := readFileStr("tests/toml/correct_verify.toml"); ok {
		result := toml.parse(input)
    if error := result.getError(); error != null {
      printf("%s\n", toml.formatError(error, input))
      return
    }

    printf("%s\n", repr(result))
		expectToEqual(str(result.data["a-_"]), "Dam")
		expectToEqual(str(result.data["1"]), "A\"hh")
		expectToEqual(str(result.data["\"I love you\""]), "too")
    expectToEqual(str(map[str]interface{}(result.data["game"])["fps"]), "60")
    expectToEqualBool(bool(map[str]interface{}(result.data["debug"])["editor"]), true)
    expectToEqualBool(bool(map[str]interface{}(map[str]interface{}(result.data["debug"])["game"])["player position"]), false)

    expectToEqualInt(int(map[str]interface{}(result.data["numbers"])["integer"]), 123)
    expectToEqualInt(int(map[str]interface{}(result.data["numbers"])["integer_underscored"]), 123456)
    expectToEqualInt(int(map[str]interface{}(result.data["numbers"])["integer_negative"]), -123456)
    expectToEqualInt(int(map[str]interface{}(result.data["numbers"])["mcdonalds_phone_number"]), +15123358065)
    expectToEqualReal(real(map[str]interface{}(result.data["numbers"])["floating_point"]), 123.456)
	}

  if fail {
    printf("\x1b[31mSOMETHING FAILED!\n\x1b[0m")
  } else {
    printf("\x1b[32mAll good!\x1b[0m")
  }
}